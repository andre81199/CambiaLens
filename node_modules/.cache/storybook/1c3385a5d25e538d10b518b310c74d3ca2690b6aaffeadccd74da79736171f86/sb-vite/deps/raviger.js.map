{
  "version": 3,
  "sources": ["../../../../../.pnpm/raviger@4.1.2_react@18.3.1/node_modules/raviger/src/context.tsx", "../../../../../.pnpm/raviger@4.1.2_react@18.3.1/node_modules/raviger/src/node.ts", "../../../../../.pnpm/raviger@4.1.2_react@18.3.1/node_modules/raviger/src/intercept.ts", "../../../../../.pnpm/raviger@4.1.2_react@18.3.1/node_modules/raviger/src/location.ts", "../../../../../.pnpm/raviger@4.1.2_react@18.3.1/node_modules/raviger/src/hooks.ts", "../../../../../.pnpm/raviger@4.1.2_react@18.3.1/node_modules/raviger/src/typeChecks.ts", "../../../../../.pnpm/raviger@4.1.2_react@18.3.1/node_modules/raviger/src/router.tsx", "../../../../../.pnpm/raviger@4.1.2_react@18.3.1/node_modules/raviger/src/navigate.ts", "../../../../../.pnpm/raviger@4.1.2_react@18.3.1/node_modules/raviger/src/querystring.ts", "../../../../../.pnpm/raviger@4.1.2_react@18.3.1/node_modules/raviger/src/redirect.ts", "../../../../../.pnpm/raviger@4.1.2_react@18.3.1/node_modules/raviger/src/Link.tsx"],
  "sourcesContent": ["import React, { createContext, useContext, useMemo } from 'react'\n\nconst BasePathContext = createContext('')\nconst PathContext = createContext<string | null>(null)\n\nexport { BasePathContext }\nexport { PathContext }\n\nexport function useRouter(): { basePath: string; path: string | null } {\n  const [basePath, path] = [useContext(BasePathContext), useContext(PathContext)]\n  return useMemo(() => ({ basePath, path }), [basePath, path])\n}\n\nexport function RouterProvider({\n  basePath = '',\n  path,\n  children,\n}: {\n  basePath?: string\n  path?: string\n  children?: React.ReactNode\n}): JSX.Element {\n  return (\n    // The ordering here is important, the basePath will change less often\n    // So putting it on the outside reduces its need to re-render\n    <BasePathContext.Provider value={basePath}>\n      <PathContext.Provider value={path ?? null}>{children}</PathContext.Provider>\n    </BasePathContext.Provider>\n  )\n}\n", "let ssrPath = '/'\nlet isNode = true\ntry {\n  isNode = window === undefined\n} catch (e) {} // eslint-disable-line no-empty\n\nexport { isNode }\nexport function getSsrPath(): string {\n  return ssrPath\n}\nexport function setSsrPath(path: string): void {\n  ssrPath = path\n}\n", "const interceptors = new Set<() => string | void>()\n\nexport const defaultPrompt = 'Are you sure you want to leave this page?'\n\nlet hasIntercepted = false\nlet hasUserCancelled = false\nlet lastScroll = [0, 0] as [number, number]\n\nexport function shouldCancelNavigation(): boolean {\n  lastScroll = [window.scrollX, window.scrollY]\n  if (hasIntercepted) return hasUserCancelled\n\n  // confirm if any interceptors return true\n  return Array.from(interceptors).some((interceptor) => {\n    const prompt = interceptor()\n    if (!prompt) return false\n\n    // cancel navigation if user declines\n    hasUserCancelled = !window.confirm(prompt) // eslint-disable-line no-alert\n\n    // track user response so that multiple interceptors don't prompt\n    hasIntercepted = true\n\n    // reset so that future navigation attempts are prompted\n    setTimeout(() => {\n      hasIntercepted = false\n      hasUserCancelled = false\n    }, 0)\n\n    return hasUserCancelled\n  })\n}\n\nexport function addInterceptor(handler: () => string | void): void {\n  window.addEventListener('beforeunload', handler)\n  interceptors.add(handler)\n}\n\nexport function removeInterceptor(handler: () => string | void): void {\n  window.removeEventListener('beforeunload', handler)\n  interceptors.delete(handler)\n}\n\nexport function undoNavigation(lastPath: string): void {\n  window.history.pushState(null, null as unknown as string, lastPath)\n  setTimeout(() => {\n    window.scrollTo(...lastScroll)\n  }, 0)\n}\n", "import { useState, useCallback, useRef, useContext, useLayoutEffect } from 'react'\n\nimport { BasePathContext, PathContext } from './context'\nimport { useMountedLayout } from './hooks'\nimport { getSsrPath, isNode } from './node'\nimport { shouldCancelNavigation } from './intercept'\nimport { isFunction } from './typeChecks'\n\nexport interface RavigerLocation {\n  /** The current path; alias of `pathname` */\n  path: string | null\n  /** The current path; alias of `path` */\n  pathname: string | null\n  /** The full path, ignores any `basePath` in the context */\n  fullPath: string\n  basePath?: string\n  search: string\n  hash: string\n  host: string\n  hostname: string\n  href: string\n  origin: string\n}\n\nexport interface RavigerHistory {\n  scrollRestoration: 'auto' | 'manual'\n  state: unknown\n}\n\nexport interface LocationChangeSetFn {\n  (location: RavigerLocation): void\n}\nexport interface LocationChangeOptionParams {\n  inheritBasePath?: boolean\n  basePath?: string\n  isActive?: boolean | (() => boolean)\n  onInitial?: boolean\n}\n\nexport function usePath(basePath?: string): string | null {\n  const contextPath = useContext(PathContext)\n  const contextBasePath = useBasePath() // hooks can't be called conditionally\n  basePath = basePath || contextBasePath\n\n  // Don't bother tracking the actual path, it can get out of sync\n  // due to React parent/child render ordering, especially with onmount navigation\n  // See issues:\n  // https://github.com/kyeotic/raviger/issues/116\n  // https://github.com/kyeotic/raviger/issues/64\n  //\n  // This is just used to force a re-render\n  const [, setPath] = useState(getFormattedPath(basePath))\n  const onChange = useCallback(({ path: newPath }) => setPath(newPath), [])\n  useLocationChange(onChange, {\n    basePath,\n    inheritBasePath: !basePath,\n    // Use on initial to handle to force state updates from on-mount navigation\n    onInitial: true,\n  })\n\n  return contextPath || getFormattedPath(basePath)\n}\n\nexport function useBasePath(): string {\n  return useContext(BasePathContext)\n}\n\nexport function useFullPath(): string {\n  const [path, setPath] = useState<string | null>(getCurrentPath())\n  const onChange = useCallback(({ path: newPath }) => setPath(newPath), [])\n  useLocationChange(onChange, { inheritBasePath: false })\n\n  return path || '/'\n}\n\nexport function useHash({ stripHash = true } = {}): string {\n  const [hash, setHash] = useState(window.location.hash)\n  const handleHash = useCallback(() => {\n    const newHash = window.location.hash\n    if (newHash === hash) return\n    setHash(newHash)\n  }, [setHash, hash])\n\n  useLayoutEffect(() => {\n    window.addEventListener('hashchange', handleHash, false)\n    return () => window.removeEventListener('hashchange', handleHash)\n  }, [handleHash])\n\n  useLocationChange(handleHash)\n  return stripHash ? hash.substring(1) : hash\n}\n\nexport function getCurrentPath(): string {\n  return isNode ? getSsrPath() : window.location.pathname || '/'\n}\n\nexport function getCurrentHash(): string {\n  if (isNode) {\n    const path = getSsrPath()\n    const hashIndex = path.indexOf('#')\n    return path.substring(hashIndex)\n  }\n  return window.location.hash\n}\n\nexport function useLocationChange(\n  setFn: LocationChangeSetFn,\n  {\n    inheritBasePath = true,\n    basePath = '',\n    isActive,\n    onInitial = false,\n  }: LocationChangeOptionParams = {}\n): void {\n  if (isNode) return\n\n  // All hooks after this are conditional, but the runtime can't actually change\n  /* eslint-disable react-hooks/rules-of-hooks */\n\n  const routerBasePath = useBasePath()\n  if (inheritBasePath && routerBasePath) basePath = routerBasePath\n\n  const setRef = useRef<LocationChangeSetFn>(setFn)\n  useLayoutEffect(() => {\n    // setFn could be an in-render declared callback, making it unstable\n    // This is a method of using an often-changing callback from React Hooks\n    // https://reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback\n    // While not recommended, it is the best current (16.9) available method\n    // For reducing the useEffect cleanup from setFn changing every render\n    setRef.current = setFn\n  })\n\n  const onPopState = useCallback(() => {\n    // No predicate defaults true\n    if (isActive !== undefined && !isPredicateActive(isActive)) return\n    if (shouldCancelNavigation()) return\n    setRef.current(getFormattedLocation(basePath))\n  }, [isActive, basePath])\n\n  useLayoutEffect(() => {\n    window.addEventListener('popstate', onPopState)\n    return () => window.removeEventListener('popstate', onPopState)\n  }, [onPopState])\n\n  // When the basePath changes re-check the path after the render completes\n  // This allows nested contexts to get an up-to-date formatted path\n  useMountedLayout(\n    () => {\n      if (isActive !== undefined && !isPredicateActive(isActive)) return\n      setRef.current(getFormattedLocation(basePath))\n    },\n    [basePath, isActive],\n    { onInitial }\n  )\n}\n\nexport function useHistory(): RavigerHistory {\n  const [history, setHistory] = useState(getRavigerHistory())\n  useLocationChange(useCallback(() => setHistory(getRavigerHistory()), [setHistory]))\n  return history\n}\n\nfunction getRavigerHistory(): RavigerHistory {\n  if (isNode) return { scrollRestoration: 'manual', state: null }\n  return {\n    scrollRestoration: window.history.scrollRestoration,\n    state: window.history.state,\n  }\n}\n\n/**\n * Returns the current path after decoding. If basePath is provided it will be removed from the front of the path.\n * If basePath is provided and the path does not begin with it will return null\n * @param {string} basePath basePath, if any\n * @return {string | null} returns path with basePath prefix removed, or null if basePath is provided and missing\n */\nexport function getFormattedPath(basePath: string): string | null {\n  const path = getCurrentPath()\n  const baseMissing = basePath && !isPathInBase(basePath, path)\n  if (path === null || baseMissing) return null\n  return decodeURIComponent(!basePath ? path : path.replace(basePathMatcher(basePath), '') || '/')\n}\n\nfunction getFormattedLocation(basePath: string): RavigerLocation {\n  const path = getFormattedPath(basePath)\n  return {\n    basePath,\n    path,\n    pathname: path,\n    fullPath: getCurrentPath(),\n    search: window.location.search,\n    hash: getCurrentHash(),\n    host: window.location.host,\n    hostname: window.location.hostname,\n    href: window.location.href,\n    origin: window.location.origin,\n  }\n}\n\nfunction isPredicateActive(predicate: boolean | (() => boolean)): boolean {\n  return isFunction(predicate) ? predicate() : predicate\n}\n\nfunction basePathMatcher(basePath: string): RegExp {\n  return new RegExp('^' + basePath, 'i')\n}\n\nfunction isPathInBase(basePath: string, path: string): boolean {\n  return !!(basePath && path && path.toLowerCase().startsWith(basePath.toLowerCase()))\n}\n", "import { useLayoutEffect, useRef } from 'react'\n\nexport function useMountedLayout(\n  fn: () => unknown,\n  deps: React.DependencyList | undefined,\n  { onInitial = false } = {}\n): void {\n  const hasMounted = useRef(onInitial)\n  useLayoutEffect(() => {\n    if (!hasMounted.current) hasMounted.current = true\n    else fn()\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps)\n}\n", "// eslint-disable-next-line @typescript-eslint/ban-types, @typescript-eslint/explicit-module-boundary-types\nexport function isFunction(obj: unknown): obj is Function {\n  return !!obj && typeof obj === 'function'\n}\n", "import React, { useCallback, useLayoutEffect, useMemo, useState } from 'react'\n\nimport { RouterProvider } from './context'\nimport { isNode, setSsrPath, getSsrPath } from './node'\nimport { getFormattedPath, usePath } from './location'\nimport type { NonEmptyRecord, Split, ValueOf } from './types'\n\nconst emptyPathResult: [null, null] = [null, null]\n\nexport interface PathParamOptions {\n  basePath?: string\n  matchTrailingSlash?: boolean\n}\nexport interface RouteOptionParams extends PathParamOptions {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  routeProps?: { [k: string]: any }\n  overridePathParams?: boolean\n}\ninterface RouteMatcher {\n  path: string\n  regex: RegExp\n  props: string[]\n}\n\ntype ExtractPathParams<Path extends string, Parts = Split<Path, '/'>> = Parts extends [\n  infer Head,\n  ...infer Tail\n]\n  ? Head extends `:${infer Name}`\n    ? { [N in Name]: string } & ExtractPathParams<Path, Tail>\n    : ExtractPathParams<Path, Tail>\n  : unknown\n\nexport type Routes<Path extends string> = {\n  [P in Path]: (\n    params: NonEmptyRecord<ExtractPathParams<P extends `${infer P1}*` ? P1 : P>>\n  ) => JSX.Element\n}\n\nexport function useRoutes<Path extends string>(\n  routes: Routes<Path>,\n  {\n    basePath = '',\n    routeProps = {},\n    overridePathParams = true,\n    matchTrailingSlash = true,\n  }: RouteOptionParams = {}\n): JSX.Element | null {\n  /*\n    This is a hack to setup a listener for the path while always using this latest path\n    The issue with usePath is that, in order to not re-render nested components when\n    their parent router changes the path, it uses the context's path\n    But since that path has to get _set_ here in useRoutes something has to give\n    If usePath returns latest it causes render thrashing\n    If useRoutes hacks itself into the latest path nothing bad happens (...afaik)\n  */\n  const path = usePath(basePath) && getFormattedPath(basePath)\n\n  // Handle potential <Redirect /> use in routes\n  useRedirectDetection(basePath, usePath(basePath))\n\n  // Get the current route\n  const route = useMatchRoute(routes, path, {\n    routeProps,\n    overridePathParams,\n    matchTrailingSlash,\n  })\n\n  // No match should not return an empty Provider, just null\n  if (!route || path === null) return null\n  return (\n    <RouterProvider basePath={basePath} path={path}>\n      {route}\n    </RouterProvider>\n  )\n}\n\nfunction useMatchRoute(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  routes: { [key: string]: (...props: any) => JSX.Element },\n  path: string | null,\n  {\n    routeProps,\n    overridePathParams,\n    matchTrailingSlash,\n  }: Omit<RouteOptionParams, 'basePath' | 'matchTrailingSlash'> & { matchTrailingSlash: boolean }\n) {\n  path = trailingMatch(path, matchTrailingSlash)\n  const matchers = useMatchers(Object.keys(routes))\n\n  if (path === null) return null\n  const [routeMatch, props] = getMatchParams(path, matchers)\n\n  if (!routeMatch) return null\n\n  return routes[routeMatch.path](\n    overridePathParams ? { ...props, ...routeProps } : { ...routeProps, ...props }\n  )\n}\n\nexport function usePathParams<Path extends string>(\n  route: Path,\n  options?: PathParamOptions\n): NonEmptyRecord<ExtractPathParams<Path extends `${infer P1}*` ? P1 : Path>> | null\nexport function usePathParams<Path extends string>(\n  routes: ReadonlyArray<Path>,\n  options?: PathParamOptions\n):\n  | ValueOf<{\n      [P in typeof routes[number]]: [\n        P,\n        NonEmptyRecord<ExtractPathParams<P extends `${infer P1}*` ? P1 : P>>\n      ]\n    }>\n  | [null, null]\nexport function usePathParams<Params extends ReadonlyArray<string> | string>(\n  routes: Params,\n  options: PathParamOptions = {}\n): Params extends ReadonlyArray<string>\n  ?\n      | ValueOf<{\n          [P in typeof routes[number]]: [\n            P,\n            NonEmptyRecord<ExtractPathParams<P extends `${infer P1}*` ? P1 : P>>\n          ]\n        }>\n      | [null, null]\n  : Params extends string\n  ? NonEmptyRecord<ExtractPathParams<Params extends `${infer P1}*` ? P1 : Params>> | null\n  : never {\n  const isSingle = !Array.isArray(routes)\n  const [path, matchers] = usePathOptions(routes as string | string[], options)\n\n  // @ts-expect-error inference is not carried forward and I don't know how to resolve this type\n  if (path === null) return isSingle ? null : emptyPathResult\n\n  const [routeMatch, props] = getMatchParams(path, matchers)\n  // @ts-expect-error inference is not carried forward and I don't know how to resolve this type\n  if (!routeMatch) return isSingle ? null : emptyPathResult\n\n  // @ts-expect-error inference is not carried forward and I don't know how to resolve this type\n  return isSingle\n    ? props\n    : ([routeMatch.path, props] as ValueOf<{\n        [P in typeof routes[number]]: [\n          P,\n          NonEmptyRecord<ExtractPathParams<P extends `${infer P1}*` ? P1 : P>>\n        ]\n      }>)\n}\n\nexport function useMatch(routes: string | string[], options: PathParamOptions = {}): string | null {\n  const [path, matchers] = usePathOptions(routes, options)\n  const match = matchers.find(({ regex }) => path?.match(regex))\n\n  return match?.path ?? null\n}\n\nfunction usePathOptions(\n  routeOrRoutes: string | string[],\n  { basePath, matchTrailingSlash = true }: PathParamOptions\n): [string | null, RouteMatcher[]] {\n  const routes = (!Array.isArray(routeOrRoutes) ? [routeOrRoutes] : routeOrRoutes) as string[]\n  const matchers = useMatchers(routes)\n\n  return [trailingMatch(usePath(basePath), matchTrailingSlash), matchers]\n}\n\nfunction useMatchers(routes: string[]): RouteMatcher[] {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return useMemo(() => routes.map(createRouteMatcher), [hashParams(routes)])\n}\n\nfunction getMatchParams(\n  path: string,\n  routeMatchers: RouteMatcher[]\n): [RouteMatcher, Record<string, unknown>] | [null, null] {\n  let pathParams: RegExpMatchArray | null = null\n\n  // Hacky method for find + map\n  const routeMatch = routeMatchers.find(({ regex }) => {\n    pathParams = path.match(regex)\n    return !!pathParams\n  })\n\n  if (!routeMatch || pathParams === null) return emptyPathResult\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const props = routeMatch.props.reduce((props: any, prop, i) => {\n    // The following `match` can't be null because the above return asserts it\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    props[prop] = pathParams![i + 1]\n    return props\n  }, {})\n\n  return [routeMatch, props]\n}\n\nfunction createRouteMatcher(path: string): RouteMatcher {\n  return {\n    path,\n    regex: new RegExp(\n      `${path.substr(0, 1) === '*' ? '' : '^'}${escapeRegExp(path)\n        .replace(/:[a-zA-Z]+/g, '([^/]+)')\n        .replace(/\\*/g, '')}${path.substr(-1) === '*' ? '' : '$'}`,\n      'i'\n    ),\n    props: (path.match(/:[a-zA-Z]+/g) ?? []).map((paramName) => paramName.substr(1)),\n  }\n}\n\nexport function setPath(path: string): void {\n  if (!isNode) {\n    throw new Error('This method should only be used in NodeJS environments')\n  }\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\n  const url = require('url')\n  setSsrPath(url.resolve(getSsrPath(), path))\n}\n\n// React doesn't like when the hook dependency array changes size\n// >> Warning: The final argument passed to useMemo changed size between renders. The order and size of this array must remain constant.\n// It is recommended to use a hashing function to produce a single, stable value\n// https://github.com/facebook/react/issues/14324#issuecomment-441489421\nfunction hashParams(params: string[]): string {\n  return [...params].sort().join(':')\n}\n\n// React appears to suppress parent's re-rendering when a child's\n// useLayoutEffect updates internal state\n// the `navigate` call in useRedirect *does* cause usePath/useLocationChange\n// to fire, but without this hack useRoutes suppresses the update\n// TODO: find a better way to cause a synchronous update from useRoutes\nfunction useRedirectDetection(basePath: string, path: string | null) {\n  const [, updateState] = useState({})\n  const forceRender = useCallback(() => updateState({}), [])\n\n  useLayoutEffect(() => {\n    if (path !== getFormattedPath(basePath)) {\n      forceRender()\n    }\n  }, [forceRender, basePath, path])\n}\n\nfunction trailingMatch(path: string | null, matchTrailingSlash: boolean): string | null {\n  if (path === null) return path\n  // path.length > 1 ensure we still match on the root route \"/\" when matchTrailingSlash is set\n  if (matchTrailingSlash && path && path[path.length - 1] === '/' && path.length > 1) {\n    path = path.substring(0, path.length - 1)\n  }\n  return path\n}\n\n// Taken from: https://stackoverflow.com/a/3561711\n// modified to NOT ESCAPE \"/\" and \"*\" since we use those as path parts\nfunction escapeRegExp(string: string): string {\n  return string.replace(/[-\\\\^$+?.()|[\\]{}]/g, '\\\\$&')\n}\n", "import { useCallback, useLayoutEffect } from 'react'\n\nimport { useBasePath } from './location'\nimport { isNode } from './node'\nimport type { QueryParam } from './querystring'\nimport {\n  shouldCancelNavigation,\n  addInterceptor,\n  removeInterceptor,\n  defaultPrompt,\n  undoNavigation,\n} from './intercept'\n\nexport interface NavigateOptions {\n  /**\n   * Use a `replace` instead of `push` for navigation\n   * @default false */\n  replace?: boolean\n  /** Values to serialize as a querystring, which will be appended to the `url` */\n  query?: QueryParam | URLSearchParams\n  /**  value to pass as the state/data to history push/replace*/\n  state?: unknown\n}\n\nlet lastPath = ''\n\nexport function navigate(url: string, options?: NavigateOptions): void {\n  if (typeof url !== 'string') {\n    throw new Error(`\"url\" must be a string, was provided a(n) ${typeof url}`)\n  }\n\n  if (Array.isArray(options?.query)) {\n    throw new Error('\"query\" a serializable object or URLSearchParams')\n  }\n\n  if (shouldCancelNavigation()) return\n  if (options?.query) {\n    url += '?' + new URLSearchParams(options.query).toString()\n  }\n\n  lastPath = url\n  // if the origin does not match history navigation will fail with\n  // \"cannot be created in a document with origin\"\n  // When navigating to another domain we must use location instead of history\n  if (isAbsolute(url) && !isCurrentOrigin(url)) {\n    window.location.assign(url)\n    return\n  }\n\n  if (options?.replace) window.history.replaceState(options?.state, '', url)\n  else window.history.pushState(options?.state, '', url)\n\n  const event = new PopStateEvent('popstate')\n  // Tag the event so navigation can be filtered out from browser events\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ;(event as any).__tag = 'raviger:navigation'\n  dispatchEvent(event)\n}\n\nexport function useNavigationPrompt(predicate = true, prompt: string = defaultPrompt): void {\n  if (isNode) return\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  useLayoutEffect(() => {\n    const onPopStateNavigation = () => {\n      if (shouldCancelNavigation()) {\n        undoNavigation(lastPath)\n      }\n    }\n    window.addEventListener('popstate', onPopStateNavigation)\n    return () => window.removeEventListener('popstate', onPopStateNavigation)\n  }, [])\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  useLayoutEffect(() => {\n    const handler = (e?: BeforeUnloadEvent): string | void => {\n      if (predicate) {\n        return e ? cancelNavigation(e, prompt) : prompt\n      }\n    }\n    addInterceptor(handler)\n    return () => removeInterceptor(handler)\n  }, [predicate, prompt])\n}\n\nfunction cancelNavigation(event: BeforeUnloadEvent, prompt: string) {\n  // Cancel the event as stated by the standard.\n  event.preventDefault()\n  // Chrome requires returnValue to be set.\n  event.returnValue = prompt\n  // Return value for prompt per spec\n  return prompt\n}\n\nexport function useNavigate(optBasePath = ''): typeof navigate {\n  const basePath = useBasePath()\n  const navigateWithBasePath = useCallback<typeof navigate>(\n    (url: string, options?: NavigateOptions) => {\n      const base = optBasePath || basePath\n      const href = url.startsWith('/') ? base + url : url\n      navigate(href, options)\n    },\n    [basePath, optBasePath]\n  )\n  return navigateWithBasePath\n}\n\nfunction isAbsolute(url: string) {\n  return /^(?:[a-z]+:)?\\/\\//i.test(url)\n}\n\nfunction isCurrentOrigin(url: string) {\n  return window.location.origin === new URL(url).origin\n}\n", "import { useState, useCallback } from 'react'\n\nimport { navigate } from './navigate'\nimport { isNode, getSsrPath } from './node'\nimport { getCurrentPath, getCurrentHash, useLocationChange } from './location'\n\nexport interface QueryParam {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [key: string]: any\n}\n\nexport interface setQueryParamsOptions {\n  replace?: boolean\n}\n\nexport function useQueryParams<T extends QueryParam>(\n  parseFn: (query: string) => T = parseQuery,\n  serializeFn: (query: Partial<T>) => string = serializeQuery\n): [T, (query: T, options?: setQueryParamsOptions) => void] {\n  const [querystring, setQuerystring] = useState(getQueryString())\n  const setQueryParams = useCallback(\n    (params, { replace = true } = {}) => {\n      let path = getCurrentPath()\n      params = replace ? params : { ...parseFn(querystring), ...params }\n      const serialized = serializeFn(params).toString()\n\n      if (serialized) path += '?' + serialized\n      if (!replace) path += getCurrentHash()\n\n      navigate(path)\n    },\n    [querystring, parseFn, serializeFn]\n  )\n\n  // Update state when route changes\n  const updateQuery = useCallback(() => setQuerystring(getQueryString()), [])\n\n  useLocationChange(updateQuery)\n  return [parseFn(querystring), setQueryParams]\n}\n\nfunction parseQuery<T extends QueryParam>(querystring: string): T {\n  const q = new URLSearchParams(querystring)\n  return Object.fromEntries(q.entries()) as T\n}\n\nfunction serializeQuery<T extends QueryParam>(queryParams: T): string {\n  return new URLSearchParams(Object.entries(queryParams).filter(([, v]) => v !== null)).toString()\n}\n\nexport function getQueryString(): string {\n  if (isNode) {\n    const ssrPath = getSsrPath()\n    const queryIndex = ssrPath.indexOf('?')\n    return queryIndex === -1 ? '' : ssrPath.substring(queryIndex + 1)\n  }\n  return window.location.search\n}\n", "import { useLayoutEffect } from 'react'\n\nimport { getCurrentHash, usePath } from './location'\nimport { navigate } from './navigate'\nimport { QueryParam, useQueryParams } from './querystring'\n\nexport interface RedirectProps {\n  to: string\n  query?: QueryParam | URLSearchParams\n  replace?: boolean\n  merge?: boolean\n}\n\nexport interface UseRedirectProps {\n  predicateUrl: string\n  targetUrl: string\n  queryParams?: QueryParam | URLSearchParams\n  replace?: boolean\n}\n\nexport function Redirect({\n  to,\n  query,\n  replace = true,\n  merge = true,\n}: RedirectProps): JSX.Element | null {\n  useRedirect(usePath(), to, { query, replace, merge })\n  return null\n}\n\nexport function useRedirect(\n  predicateUrl: string | null,\n  targetUrl: string,\n  {\n    query,\n    replace = true,\n    merge = true,\n  }: { query?: QueryParam; replace?: boolean; merge?: boolean } = {}\n): void {\n  const currentPath = usePath()\n  const [currentQuery] = useQueryParams()\n  const hash = getCurrentHash()\n\n  let url = targetUrl\n  const targetQuery = new URLSearchParams({\n    ...(merge ? currentQuery : {}),\n    ...query,\n  }).toString()\n  if (targetQuery) {\n    url += '?' + targetQuery\n  }\n  if (merge && hash && hash.length) {\n    url += hash\n  }\n\n  useLayoutEffect(() => {\n    if (currentPath === predicateUrl) {\n      navigate(url, { replace })\n    }\n  }, [predicateUrl, url, replace, currentPath])\n}\n", "import React, { useCallback, forwardRef, Ref } from 'react'\n\nimport { navigate } from './navigate'\nimport { useBasePath, useFullPath } from './location'\n\nexport interface LinkProps extends React.AnchorHTMLAttributes<HTMLAnchorElement> {\n  href: string\n  basePath?: string\n  children?: React.ReactNode\n}\nexport type LinkRef = HTMLAnchorElement | null\n\nexport interface ActiveLinkProps extends LinkProps {\n  activeClass?: string\n  exactActiveClass?: string\n}\n\nfunction Link({ href, basePath, ...props }: LinkProps, ref?: Ref<HTMLAnchorElement>) {\n  basePath = useLinkBasePath(basePath)\n  href = getLinkHref(href, basePath)\n\n  const { onClick, target } = props\n\n  const handleClick = useCallback<React.MouseEventHandler<HTMLAnchorElement>>(\n    (e) => {\n      try {\n        if (onClick) onClick(e)\n      } catch (ex) {\n        e.preventDefault()\n        throw ex\n      }\n      if (shouldTrap(e, target)) {\n        e.preventDefault() // prevent the link from actually navigating\n        navigate(e.currentTarget.href)\n      }\n    },\n    [onClick, target]\n  )\n\n  return <a {...props} href={href} onClick={handleClick} ref={ref} />\n}\n\nconst RefLink = forwardRef<LinkRef, LinkProps>(Link) as (\n  props: LinkProps & { ref?: React.ForwardedRef<HTMLAnchorElement> }\n) => ReturnType<typeof Link>\n\nexport default RefLink\nexport { RefLink as Link }\n\nfunction ActiveLink(\n  { basePath, className, exactActiveClass, activeClass, ...props }: ActiveLinkProps,\n  ref?: Ref<HTMLAnchorElement>\n) {\n  basePath = useLinkBasePath(basePath)\n  const fullPath = useFullPath()\n\n  let { href } = props\n  href = absolutePathName(getLinkHref(href, basePath))\n\n  if (exactActiveClass && fullPath === href)\n    className = `${className ?? ``} ${exactActiveClass}`.trim()\n  if (activeClass && fullPath.startsWith(href))\n    className = `${className ?? ``} ${activeClass}`.trim()\n\n  return <RefLink {...props} basePath={basePath} className={className} ref={ref} />\n}\n\nconst ActiveLinkRef = forwardRef<LinkRef, ActiveLinkProps>(ActiveLink) as (\n  props: ActiveLinkProps & { ref?: React.ForwardedRef<HTMLAnchorElement> }\n) => ReturnType<typeof ActiveLink>\n\nexport { ActiveLinkRef as ActiveLink }\n\nfunction useLinkBasePath(basePath?: string): string {\n  const contextBasePath = useBasePath()\n  if (basePath === '/') return ''\n  return basePath || contextBasePath\n}\n\nfunction getLinkHref(href: string, basePath = '') {\n  return href.startsWith('/') ? basePath + href : href\n}\n\nfunction absolutePathName(href: string): string {\n  if (href.startsWith('/')) return href\n  return new URL(href, document.baseURI).pathname\n}\n\nfunction shouldTrap(e: React.MouseEvent<HTMLAnchorElement, MouseEvent>, target?: string) {\n  return (\n    !e.defaultPrevented && // onClick prevented default\n    e.button === 0 && // ignore everything but left clicks\n    !(target || target === '_self') && // don't trap target === blank\n    !(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\n  )\n}\n"],
  "mappings": "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",
  "names": ["BasePathContext", "createContext", "PathContext", "RouterProvider", "basePath", "path", "children", "React", "createElement", "Provider", "value", "isNode", "window", "e", "interceptors", "Set", "hasIntercepted", "hasUserCancelled", "lastScroll", "shouldCancelNavigation", "scrollX", "scrollY", "Array", "from", "some", "interceptor", "prompt", "confirm", "setTimeout", "usePath", "contextPath", "useContext", "contextBasePath", "useBasePath", "setPath", "useState", "getFormattedPath", "useLocationChange", "useCallback", "newPath", "inheritBasePath", "onInitial", "useFullPath", "getCurrentPath", "useHash", "stripHash", "hash", "setHash", "location", "handleHash", "newHash", "useLayoutEffect", "addEventListener", "removeEventListener", "substring", "pathname", "getCurrentHash", "hashIndex", "indexOf", "setFn", "isActive", "routerBasePath", "setRef", "useRef", "current", "onPopState", "isPredicateActive", "getFormattedLocation", "useMountedLayout", "fn", "deps", "hasMounted", "useHistory", "history", "setHistory", "getRavigerHistory", "scrollRestoration", "state", "baseMissing", "isPathInBase", "toLowerCase", "startsWith", "decodeURIComponent", "replace", "basePathMatcher", "RegExp", "fullPath", "search", "host", "hostname", "href", "origin", "predicate", "isFunction", "obj", "emptyPathResult", "useRoutes", "routes", "routeProps", "overridePathParams", "matchTrailingSlash", "useRedirectDetection", "updateState", "forceRender", "route", "useMatchRoute", "trailingMatch", "matchers", "useMatchers", "Object", "keys", "routeMatch", "props", "getMatchParams", "usePathParams", "options", "isSingle", "isArray", "usePathOptions", "useMatch", "n", "match", "find", "regex", "_a", "routeOrRoutes", "useMemo", "map", "createRouteMatcher", "params", "sort", "join", "routeMatchers", "pathParams", "reduce", "prop", "i", "string", "substr", "paramName", "length", "lastPath", "navigate", "url", "Error", "query", "URLSearchParams", "toString", "isAbsolute", "test", "isCurrentOrigin", "URL", "assign", "replaceState", "pushState", "event", "PopStateEvent", "__tag", "dispatchEvent", "useNavigationPrompt", "onPopStateNavigation", "undoNavigation", "scrollTo", "handler", "cancelNavigation", "preventDefault", "returnValue", "addInterceptor", "add", "removeInterceptor", "delete", "useNavigate", "optBasePath", "base", "useQueryParams", "parseFn", "parseQuery", "serializeFn", "serializeQuery", "querystring", "setQuerystring", "getQueryString", "setQueryParams", "serialized", "q", "fromEntries", "entries", "queryParams", "filter", "v", "ssrPath", "queryIndex", "Redirect", "to", "merge", "useRedirect", "predicateUrl", "targetUrl", "currentPath", "currentQuery", "targetQuery", "RefLink", "forwardRef", "Link", "ref", "getLinkHref", "useLinkBasePath", "onClick", "target", "handleClick", "ex", "shouldTrap", "defaultPrevented", "button", "metaKey", "altKey", "ctrlKey", "shiftKey", "currentTarget", "ActiveLinkRef", "ActiveLink", "className", "exactActiveClass", "activeClass", "absolutePathName", "document", "baseURI", "trim"]
}
