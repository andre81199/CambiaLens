{
  "version": 3,
  "sources": ["../../../../../.pnpm/outvariant@1.4.2/node_modules/outvariant/src/index.ts", "../../../../../.pnpm/outvariant@1.4.2/node_modules/outvariant/src/format.ts", "../../../../../.pnpm/outvariant@1.4.2/node_modules/outvariant/src/invariant.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/core/utils/internal/devUtils.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/core/utils/internal/getCallFrame.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/core/utils/internal/isIterable.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/core/handlers/RequestHandler.ts", "../../../../../.pnpm/@open-draft+until@2.1.0/node_modules/@open-draft/until/src/index.ts", "../../../../../.pnpm/@open-draft+until@2.1.0/node_modules/@open-draft/until/src/until.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/core/utils/executeHandlers.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/core/utils/request/toPublicUrl.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/core/utils/request/onUnhandledRequest.ts", "../../../../../.pnpm/@mswjs+cookies@1.1.0/node_modules/@mswjs/cookies/node_modules/set-cookie-parser/lib/set-cookie.js", "../../../../../.pnpm/@mswjs+cookies@1.1.0/node_modules/@mswjs/cookies/src/store.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/core/utils/request/readResponseCookies.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/core/utils/handleRequest.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/core/utils/toResponseInit.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/core/utils/internal/isObject.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/core/utils/internal/mergeRight.ts", "../../../../../.pnpm/strict-event-emitter@0.5.1/node_modules/strict-event-emitter/src/index.ts", "../../../../../.pnpm/strict-event-emitter@0.5.1/node_modules/strict-event-emitter/src/MemoryLeakError.ts", "../../../../../.pnpm/strict-event-emitter@0.5.1/node_modules/strict-event-emitter/src/Emitter.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/core/utils/internal/pipeEvents.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/core/utils/internal/toReadonlyArray.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/core/utils/internal/Disposable.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/core/SetupApi.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/browser/index.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/node_modules/.pnpm/outvariant@1.4.2/node_modules/outvariant/src/format.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/node_modules/.pnpm/outvariant@1.4.2/node_modules/outvariant/src/invariant.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/node_modules/.pnpm/is-node-process@1.2.0/node_modules/is-node-process/src/index.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/browser/setupWorker/start/createStartHandler.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/node_modules/.pnpm/@open-draft+until@2.1.0/node_modules/@open-draft/until/src/until.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/browser/setupWorker/start/utils/getWorkerInstance.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/browser/utils/getAbsoluteWorkerUrl.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/browser/setupWorker/start/utils/getWorkerByRegistration.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/browser/setupWorker/start/utils/enableMocking.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/browser/setupWorker/start/utils/printStartMessage.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/browser/setupWorker/start/utils/createMessageChannel.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/browser/utils/pruneGetRequestBody.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/browser/utils/parseWorkerRequest.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/browser/setupWorker/start/createRequestListener.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/browser/utils/checkWorkerIntegrity.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.15/node_modules/@mswjs/interceptors/src/utils/bufferUtils.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.15/node_modules/@mswjs/interceptors/src/utils/responseUtils.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.15/node_modules/@mswjs/interceptors/src/glossary.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/node_modules/.pnpm/@open-draft+logger@0.3.0/node_modules/@open-draft/logger/lib/index.mjs", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/node_modules/.pnpm/strict-event-emitter@0.5.1/node_modules/strict-event-emitter/src/MemoryLeakError.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/node_modules/.pnpm/strict-event-emitter@0.5.1/node_modules/strict-event-emitter/src/Emitter.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.15/node_modules/@mswjs/interceptors/src/Interceptor.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.15/node_modules/@mswjs/interceptors/src/createRequestId.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.15/node_modules/@mswjs/interceptors/src/BatchInterceptor.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.15/node_modules/@mswjs/interceptors/src/utils/getCleanUrl.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/browser/setupWorker/start/createResponseListener.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/browser/setupWorker/start/utils/validateWorkerScope.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/browser/setupWorker/stop/createStop.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/browser/setupWorker/stop/utils/printStopMessage.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/browser/setupWorker/start/utils/prepareStartHandler.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/node_modules/.pnpm/@open-draft+deferred-promise@2.2.0/node_modules/@open-draft/deferred-promise/src/createDeferredExecutor.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/node_modules/.pnpm/@open-draft+deferred-promise@2.2.0/node_modules/@open-draft/deferred-promise/src/DeferredPromise.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.15/node_modules/@mswjs/interceptors/src/utils/RequestController.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.15/node_modules/@mswjs/interceptors/src/utils/toInteractiveRequest.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.15/node_modules/@mswjs/interceptors/src/utils/emitAsync.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.15/node_modules/@mswjs/interceptors/src/interceptors/fetch/index.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.15/node_modules/@mswjs/interceptors/src/utils/isPropertyAccessible.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.15/node_modules/@mswjs/interceptors/src/utils/canParseUrl.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.15/node_modules/@mswjs/interceptors/src/interceptors/XMLHttpRequest/index.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.15/node_modules/@mswjs/interceptors/src/interceptors/XMLHttpRequest/XMLHttpRequestProxy.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.15/node_modules/@mswjs/interceptors/src/interceptors/XMLHttpRequest/XMLHttpRequestController.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.15/node_modules/@mswjs/interceptors/src/interceptors/XMLHttpRequest/utils/concatArrayBuffer.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.15/node_modules/@mswjs/interceptors/src/interceptors/XMLHttpRequest/polyfills/EventPolyfill.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.15/node_modules/@mswjs/interceptors/src/interceptors/XMLHttpRequest/polyfills/ProgressEventPolyfill.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.15/node_modules/@mswjs/interceptors/src/interceptors/XMLHttpRequest/utils/createEvent.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.15/node_modules/@mswjs/interceptors/src/utils/findPropertySource.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.15/node_modules/@mswjs/interceptors/src/utils/createProxy.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.15/node_modules/@mswjs/interceptors/src/interceptors/XMLHttpRequest/utils/isDomParserSupportedType.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.15/node_modules/@mswjs/interceptors/src/utils/parseJson.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.15/node_modules/@mswjs/interceptors/src/interceptors/XMLHttpRequest/utils/createResponse.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/browser/setupWorker/start/createFallbackRequestListener.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/browser/setupWorker/start/createFallbackStart.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/browser/setupWorker/stop/createFallbackStop.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/browser/setupWorker/setupWorker.ts", "../../../../../.pnpm/msw@2.2.14_typescript@5.4.5/node_modules/msw/src/browser/utils/supportsReadableStreamTransfer.ts", "../../../../../.pnpm/msw-storybook-addon@2.0.0-beta.1_msw@2.2.14_typescript@5.4.5_/node_modules/msw-storybook-addon/dist/index.browser.js"],
  "sourcesContent": ["export * from './invariant'\nexport * from './format'\n", "const POSITIONALS_EXP = /(%?)(%([sdijo]))/g\n\nfunction serializePositional(positional: any, flag: string): any {\n  switch (flag) {\n    // Strings.\n    case 's':\n      return positional\n\n    // Digits.\n    case 'd':\n    case 'i':\n      return Number(positional)\n\n    // JSON.\n    case 'j':\n      return JSON.stringify(positional)\n\n    // Objects.\n    case 'o': {\n      // Preserve stings to prevent extra quotes around them.\n      if (typeof positional === 'string') {\n        return positional\n      }\n\n      const json = JSON.stringify(positional)\n\n      // If the positional isn't serializable, return it as-is.\n      if (json === '{}' || json === '[]' || /^\\[object .+?\\]$/.test(json)) {\n        return positional\n      }\n\n      return json\n    }\n  }\n}\n\nexport function format(message: string, ...positionals: any[]): string {\n  if (positionals.length === 0) {\n    return message\n  }\n\n  let positionalIndex = 0\n  let formattedMessage = message.replace(\n    POSITIONALS_EXP,\n    (match, isEscaped, _, flag) => {\n      const positional = positionals[positionalIndex]\n      const value = serializePositional(positional, flag)\n\n      if (!isEscaped) {\n        positionalIndex++\n        return value\n      }\n\n      return match\n    }\n  )\n\n  // Append unresolved positionals to string as-is.\n  if (positionalIndex < positionals.length) {\n    formattedMessage += ` ${positionals.slice(positionalIndex).join(' ')}`\n  }\n\n  formattedMessage = formattedMessage.replace(/%{2,2}/g, '%')\n\n  return formattedMessage\n}\n", "import { format } from './format'\n\nconst STACK_FRAMES_TO_IGNORE = 2\n\n/**\n * Remove the \"outvariant\" package trace from the given error.\n * This scopes down the error stack to the relevant parts\n * when used in other applications.\n */\nfunction cleanErrorStack(error: Error): void {\n  if (!error.stack) {\n    return\n  }\n\n  const nextStack = error.stack.split('\\n')\n  nextStack.splice(1, STACK_FRAMES_TO_IGNORE)\n  error.stack = nextStack.join('\\n')\n}\n\nexport class InvariantError extends Error {\n  name = 'Invariant Violation'\n\n  constructor(public readonly message: string, ...positionals: any[]) {\n    super(message)\n    this.message = format(message, ...positionals)\n    cleanErrorStack(this)\n  }\n}\n\nexport interface CustomErrorConstructor {\n  new (message: string): Error\n}\n\nexport interface CustomErrorFactory {\n  (message: string): Error\n}\n\nexport type CustomError = CustomErrorConstructor | CustomErrorFactory\n\ntype Invariant = {\n  (\n    predicate: unknown,\n    message: string,\n    ...positionals: any[]\n  ): asserts predicate\n\n  as(\n    ErrorConstructor: CustomError,\n    predicate: unknown,\n    message: string,\n    ...positionals: unknown[]\n  ): asserts predicate\n}\n\nexport const invariant: Invariant = (\n  predicate,\n  message,\n  ...positionals\n): asserts predicate => {\n  if (!predicate) {\n    throw new InvariantError(message, ...positionals)\n  }\n}\n\ninvariant.as = (ErrorConstructor, predicate, message, ...positionals) => {\n  if (!predicate) {\n    const formatMessage = positionals.length === 0 ? message : format(message, positionals);\n    let error: Error;\n\n    try {\n      error = Reflect.construct(ErrorConstructor as CustomErrorConstructor, [formatMessage]);\n    } catch(err) {\n      error = (ErrorConstructor as CustomErrorFactory)(formatMessage);\n    }\n\n    throw error\n  }\n}\n", "import { format } from 'outvariant'\n\nconst LIBRARY_PREFIX = '[MSW]'\n\n/**\n * Formats a given message by appending the library's prefix string.\n */\nfunction formatMessage(message: string, ...positionals: any[]): string {\n  const interpolatedMessage = format(message, ...positionals)\n  return `${LIBRARY_PREFIX} ${interpolatedMessage}`\n}\n\n/**\n * Prints a library-specific warning.\n */\nfunction warn(message: string, ...positionals: any[]): void {\n  console.warn(formatMessage(message, ...positionals))\n}\n\n/**\n * Prints a library-specific error.\n */\nfunction error(message: string, ...positionals: any[]): void {\n  console.error(formatMessage(message, ...positionals))\n}\n\nexport const devUtils = {\n  formatMessage,\n  warn,\n  error,\n}\n", "// Ignore the source files traces for local testing.\nconst SOURCE_FRAME = /[\\/\\\\]msw[\\/\\\\]src[\\/\\\\](.+)/\n\nconst BUILD_FRAME =\n  /(node_modules)?[\\/\\\\]lib[\\/\\\\](core|browser|node|native|iife)[\\/\\\\]|^[^\\/\\\\]*$/\n\n/**\n * Return the stack trace frame of a function's invocation.\n */\nexport function getCallFrame(error: Error) {\n  // In <IE11, new Error may return an undefined stack\n  const stack = error.stack\n\n  if (!stack) {\n    return\n  }\n\n  const frames: string[] = stack.split('\\n').slice(1)\n\n  // Get the first frame that doesn't reference the library's internal trace.\n  // Assume that frame is the invocation frame.\n  const declarationFrame = frames.find((frame) => {\n    return !(SOURCE_FRAME.test(frame) || BUILD_FRAME.test(frame))\n  })\n\n  if (!declarationFrame) {\n    return\n  }\n\n  // Extract file reference from the stack frame.\n  const declarationPath = declarationFrame\n    .replace(/\\s*at [^()]*\\(([^)]+)\\)/, '$1')\n    .replace(/^@/, '')\n  return declarationPath\n}\n", "/**\n * Determines if the given function is an iterator.\n */\nexport function isIterable<IteratorType>(\n  fn: any,\n): fn is Generator<IteratorType, IteratorType, IteratorType> {\n  if (!fn) {\n    return false\n  }\n\n  return typeof (fn as Generator<unknown>)[Symbol.iterator] == 'function'\n}\n", "import { invariant } from 'outvariant'\nimport { getCallFrame } from '../utils/internal/getCallFrame'\nimport { isIterable } from '../utils/internal/isIterable'\nimport type { ResponseResolutionContext } from '../utils/executeHandlers'\nimport type { MaybePromise } from '../typeUtils'\nimport { StrictRequest, StrictResponse } from '..//HttpResponse'\n\nexport type DefaultRequestMultipartBody = Record<\n  string,\n  string | File | Array<string | File>\n>\n\nexport type DefaultBodyType =\n  | Record<string, any>\n  | DefaultRequestMultipartBody\n  | string\n  | number\n  | boolean\n  | null\n  | undefined\n\nexport type JsonBodyType =\n  | Record<string, any>\n  | string\n  | number\n  | boolean\n  | null\n  | undefined\n\nexport interface RequestHandlerDefaultInfo {\n  header: string\n}\n\nexport interface RequestHandlerInternalInfo {\n  callFrame?: string\n}\n\nexport type ResponseResolverReturnType<\n  ResponseBodyType extends DefaultBodyType = undefined,\n> =\n  | ([ResponseBodyType] extends [undefined]\n      ? Response\n      : StrictResponse<ResponseBodyType>)\n  | undefined\n  | void\n\nexport type MaybeAsyncResponseResolverReturnType<\n  ResponseBodyType extends DefaultBodyType,\n> = MaybePromise<ResponseResolverReturnType<ResponseBodyType>>\n\nexport type AsyncResponseResolverReturnType<\n  ResponseBodyType extends DefaultBodyType,\n> = MaybePromise<\n  | ResponseResolverReturnType<ResponseBodyType>\n  | Generator<\n      MaybeAsyncResponseResolverReturnType<ResponseBodyType>,\n      MaybeAsyncResponseResolverReturnType<ResponseBodyType>,\n      MaybeAsyncResponseResolverReturnType<ResponseBodyType>\n    >\n>\n\nexport type ResponseResolverInfo<\n  ResolverExtraInfo extends Record<string, unknown>,\n  RequestBodyType extends DefaultBodyType = DefaultBodyType,\n> = {\n  request: StrictRequest<RequestBodyType>\n  requestId: string\n} & ResolverExtraInfo\n\nexport type ResponseResolver<\n  ResolverExtraInfo extends Record<string, unknown> = Record<string, unknown>,\n  RequestBodyType extends DefaultBodyType = DefaultBodyType,\n  ResponseBodyType extends DefaultBodyType = undefined,\n> = (\n  info: ResponseResolverInfo<ResolverExtraInfo, RequestBodyType>,\n) => AsyncResponseResolverReturnType<ResponseBodyType>\n\nexport interface RequestHandlerArgs<\n  HandlerInfo,\n  HandlerOptions extends RequestHandlerOptions,\n> {\n  info: HandlerInfo\n  resolver: ResponseResolver<any>\n  options?: HandlerOptions\n}\n\nexport interface RequestHandlerOptions {\n  once?: boolean\n}\n\nexport interface RequestHandlerExecutionResult<\n  ParsedResult extends Record<string, unknown> | undefined,\n> {\n  handler: RequestHandler\n  parsedResult?: ParsedResult\n  request: Request\n  requestId: string\n  response?: Response\n}\n\nexport abstract class RequestHandler<\n  HandlerInfo extends RequestHandlerDefaultInfo = RequestHandlerDefaultInfo,\n  ParsedResult extends Record<string, any> | undefined = any,\n  ResolverExtras extends Record<string, unknown> = any,\n  HandlerOptions extends RequestHandlerOptions = RequestHandlerOptions,\n> {\n  static cache = new WeakMap<\n    StrictRequest<DefaultBodyType>,\n    StrictRequest<DefaultBodyType>\n  >()\n\n  public info: HandlerInfo & RequestHandlerInternalInfo\n  /**\n   * Indicates whether this request handler has been used\n   * (its resolver has successfully executed).\n   */\n  public isUsed: boolean\n\n  protected resolver: ResponseResolver<ResolverExtras, any, any>\n  private resolverGenerator?: Generator<\n    MaybeAsyncResponseResolverReturnType<any>,\n    MaybeAsyncResponseResolverReturnType<any>,\n    MaybeAsyncResponseResolverReturnType<any>\n  >\n  private resolverGeneratorResult?: Response | StrictResponse<any>\n  private options?: HandlerOptions\n\n  constructor(args: RequestHandlerArgs<HandlerInfo, HandlerOptions>) {\n    this.resolver = args.resolver\n    this.options = args.options\n\n    const callFrame = getCallFrame(new Error())\n\n    this.info = {\n      ...args.info,\n      callFrame,\n    }\n\n    this.isUsed = false\n  }\n\n  /**\n   * Determine if the intercepted request should be mocked.\n   */\n  abstract predicate(args: {\n    request: Request\n    parsedResult: ParsedResult\n    resolutionContext?: ResponseResolutionContext\n  }): boolean\n\n  /**\n   * Print out the successfully handled request.\n   */\n  abstract log(args: {\n    request: Request\n    response: Response\n    parsedResult: ParsedResult\n  }): void\n\n  /**\n   * Parse the intercepted request to extract additional information from it.\n   * Parsed result is then exposed to other methods of this request handler.\n   */\n  async parse(_args: {\n    request: Request\n    resolutionContext?: ResponseResolutionContext\n  }): Promise<ParsedResult> {\n    return {} as ParsedResult\n  }\n\n  /**\n   * Test if this handler matches the given request.\n   *\n   * This method is not used internally but is exposed\n   * as a convenience method for consumers writing custom\n   * handlers.\n   */\n  public async test(args: {\n    request: Request\n    resolutionContext?: ResponseResolutionContext\n  }): Promise<boolean> {\n    const parsedResult = await this.parse({\n      request: args.request,\n      resolutionContext: args.resolutionContext,\n    })\n\n    return this.predicate({\n      request: args.request,\n      parsedResult,\n      resolutionContext: args.resolutionContext,\n    })\n  }\n\n  protected extendResolverArgs(_args: {\n    request: Request\n    parsedResult: ParsedResult\n  }): ResolverExtras {\n    return {} as ResolverExtras\n  }\n\n  // Clone the request instance before it's passed to the handler phases\n  // and the response resolver so we can always read it for logging.\n  // We only clone it once per request to avoid unnecessary overhead.\n  private cloneRequestOrGetFromCache(\n    request: StrictRequest<DefaultBodyType>,\n  ): StrictRequest<DefaultBodyType> {\n    const existingClone = RequestHandler.cache.get(request)\n\n    if (typeof existingClone !== 'undefined') {\n      return existingClone\n    }\n\n    const clonedRequest = request.clone()\n    RequestHandler.cache.set(request, clonedRequest)\n\n    return clonedRequest\n  }\n\n  /**\n   * Execute this request handler and produce a mocked response\n   * using the given resolver function.\n   */\n  public async run(args: {\n    request: StrictRequest<any>\n    requestId: string\n    resolutionContext?: ResponseResolutionContext\n  }): Promise<RequestHandlerExecutionResult<ParsedResult> | null> {\n    if (this.isUsed && this.options?.once) {\n      return null\n    }\n\n    // Clone the request.\n    // If this is the first time MSW handles this request, a fresh clone\n    // will be created and cached. Upon further handling of the same request,\n    // the request clone from the cache will be reused to prevent abundant\n    // \"abort\" listeners and save up resources on cloning.\n    const requestClone = this.cloneRequestOrGetFromCache(args.request)\n\n    const parsedResult = await this.parse({\n      request: args.request,\n      resolutionContext: args.resolutionContext,\n    })\n    const shouldInterceptRequest = this.predicate({\n      request: args.request,\n      parsedResult,\n      resolutionContext: args.resolutionContext,\n    })\n\n    if (!shouldInterceptRequest) {\n      return null\n    }\n\n    // Re-check isUsed, in case another request hit this handler while we were\n    // asynchronously parsing the request.\n    if (this.isUsed && this.options?.once) {\n      return null\n    }\n\n    this.isUsed = true\n\n    // Create a response extraction wrapper around the resolver\n    // since it can be both an async function and a generator.\n    const executeResolver = this.wrapResolver(this.resolver)\n\n    const resolverExtras = this.extendResolverArgs({\n      request: args.request,\n      parsedResult,\n    })\n\n    const mockedResponsePromise = (\n      executeResolver({\n        ...resolverExtras,\n        requestId: args.requestId,\n        request: args.request,\n      }) as Promise<Response>\n    ).catch((errorOrResponse) => {\n      // Allow throwing a Response instance in a response resolver.\n      if (errorOrResponse instanceof Response) {\n        return errorOrResponse\n      }\n\n      // Otherwise, throw the error as-is.\n      throw errorOrResponse\n    })\n\n    const mockedResponse = await mockedResponsePromise\n\n    const executionResult = this.createExecutionResult({\n      // Pass the cloned request to the result so that logging\n      // and other consumers could read its body once more.\n      request: requestClone,\n      requestId: args.requestId,\n      response: mockedResponse,\n      parsedResult,\n    })\n\n    return executionResult\n  }\n\n  private wrapResolver(\n    resolver: ResponseResolver<ResolverExtras>,\n  ): ResponseResolver<ResolverExtras> {\n    return async (info): Promise<ResponseResolverReturnType<any>> => {\n      const result = this.resolverGenerator || (await resolver(info))\n\n      if (isIterable<AsyncResponseResolverReturnType<any>>(result)) {\n        // Immediately mark this handler as unused.\n        // Only when the generator is done, the handler will be\n        // considered used.\n        this.isUsed = false\n\n        const { value, done } = result[Symbol.iterator]().next()\n        const nextResponse = await value\n\n        if (done) {\n          this.isUsed = true\n        }\n\n        // If the generator is done and there is no next value,\n        // return the previous generator's value.\n        if (!nextResponse && done) {\n          invariant(\n            this.resolverGeneratorResult,\n            'Failed to returned a previously stored generator response: the value is not a valid Response.',\n          )\n\n          // Clone the previously stored response from the generator\n          // so that it could be read again.\n          return this.resolverGeneratorResult.clone() as StrictResponse<any>\n        }\n\n        if (!this.resolverGenerator) {\n          this.resolverGenerator = result\n        }\n\n        if (nextResponse) {\n          // Also clone the response before storing it\n          // so it could be read again.\n          this.resolverGeneratorResult = nextResponse?.clone()\n        }\n\n        return nextResponse\n      }\n\n      return result\n    }\n  }\n\n  private createExecutionResult(args: {\n    request: Request\n    requestId: string\n    parsedResult: ParsedResult\n    response?: Response\n  }): RequestHandlerExecutionResult<ParsedResult> {\n    return {\n      handler: this,\n      request: args.request,\n      requestId: args.requestId,\n      response: args.response,\n      parsedResult: args.parsedResult,\n    }\n  }\n}\n", "export { until } from './until'", "export type AsyncTuple<\n  ErrorType extends any = Error,\n  DataType extends any = unknown,\n> =\n  | {\n      error: ErrorType\n      data: null\n    }\n  | { error: null; data: DataType }\n\n/**\n * Gracefully handles a given Promise factory.\n * @example\n * const { error, data } = await until(() => asyncAction())\n */\nexport const until = async <\n  ErrorType extends any = Error,\n  DataType extends any = unknown,\n>(\n  promise: () => Promise<DataType>,\n): Promise<AsyncTuple<ErrorType, DataType>> => {\n  try {\n    const data = await promise().catch((error) => {\n      throw error\n    })\n    return { error: null, data }\n  } catch (error) {\n    return { error, data: null }\n  }\n}\n", "import {\n  RequestHandler,\n  RequestHandlerExecutionResult,\n} from '../handlers/RequestHandler'\n\nexport interface HandlersExecutionResult {\n  handler: RequestHandler\n  parsedResult?: any\n  response?: Response\n}\n\nexport interface ResponseResolutionContext {\n  baseUrl?: string\n}\n\n/**\n * Executes the list of request handlers against the given request.\n * Returns the execution result object containing any matching request\n * handler and any mocked response it returned.\n */\nexport const executeHandlers = async <Handlers extends Array<RequestHandler>>({\n  request,\n  requestId,\n  handlers,\n  resolutionContext,\n}: {\n  request: Request\n  requestId: string\n  handlers: Handlers\n  resolutionContext?: ResponseResolutionContext\n}): Promise<HandlersExecutionResult | null> => {\n  let matchingHandler: RequestHandler | null = null\n  let result: RequestHandlerExecutionResult<any> | null = null\n\n  for (const handler of handlers) {\n    result = await handler.run({ request, requestId, resolutionContext })\n\n    // If the handler produces some result for this request,\n    // it automatically becomes matching.\n    if (result !== null) {\n      matchingHandler = handler\n    }\n\n    // Stop the lookup if this handler returns a mocked response.\n    // If it doesn't, it will still be considered the last matching\n    // handler until any of them returns a response. This way we can\n    // distinguish between fallthrough handlers without responses\n    // and the lack of a matching handler.\n    if (result?.response) {\n      break\n    }\n  }\n\n  if (matchingHandler) {\n    return {\n      handler: matchingHandler,\n      parsedResult: result?.parsedResult,\n      response: result?.response,\n    }\n  }\n\n  return null\n}\n", "/**\n * Returns a relative URL if the given request URL is relative\n * to the current origin. Otherwise returns an absolute URL.\n */\nexport function toPublicUrl(url: string | URL): string {\n  if (typeof location === 'undefined') {\n    return url.toString()\n  }\n\n  const urlInstance = url instanceof URL ? url : new URL(url)\n\n  return urlInstance.origin === location.origin\n    ? urlInstance.pathname\n    : urlInstance.origin + urlInstance.pathname\n}\n", "import { toPublicUrl } from './toPublicUrl'\nimport { devUtils } from '../internal/devUtils'\n\nexport interface UnhandledRequestPrint {\n  warning(): void\n  error(): void\n}\n\nexport type UnhandledRequestCallback = (\n  request: Request,\n  print: UnhandledRequestPrint,\n) => void\n\nexport type UnhandledRequestStrategy =\n  | 'bypass'\n  | 'warn'\n  | 'error'\n  | UnhandledRequestCallback\n\nexport async function onUnhandledRequest(\n  request: Request,\n  strategy: UnhandledRequestStrategy = 'warn',\n): Promise<void> {\n  const url = new URL(request.url)\n  const publicUrl = toPublicUrl(url) + url.search\n\n  const unhandledRequestMessage = `intercepted a request without a matching request handler:\\n\\n  \\u2022 ${request.method} ${publicUrl}\\n\\nIf you still wish to intercept this unhandled request, please create a request handler for it.\\nRead more: https://mswjs.io/docs/getting-started/mocks`\n\n  function applyStrategy(strategy: UnhandledRequestStrategy) {\n    switch (strategy) {\n      case 'error': {\n        // Print a developer-friendly error.\n        devUtils.error('Error: %s', unhandledRequestMessage)\n\n        // Throw an exception to halt request processing and not perform the original request.\n        throw new Error(\n          devUtils.formatMessage(\n            'Cannot bypass a request when using the \"error\" strategy for the \"onUnhandledRequest\" option.',\n          ),\n        )\n      }\n\n      case 'warn': {\n        devUtils.warn('Warning: %s', unhandledRequestMessage)\n        break\n      }\n\n      case 'bypass':\n        break\n\n      default:\n        throw new Error(\n          devUtils.formatMessage(\n            'Failed to react to an unhandled request: unknown strategy \"%s\". Please provide one of the supported strategies (\"bypass\", \"warn\", \"error\") or a custom callback function as the value of the \"onUnhandledRequest\" option.',\n            strategy,\n          ),\n        )\n    }\n  }\n\n  if (typeof strategy === 'function') {\n    strategy(request, {\n      warning: applyStrategy.bind(null, 'warn'),\n      error: applyStrategy.bind(null, 'error'),\n    })\n    return\n  }\n\n  /**\n   * @note Ignore \"file://\" requests.\n   * Those often are an implementation detail of modern tooling\n   * that fetches modules via HTTP. Developers don't issue those\n   * requests and so they mustn't be warned about them.\n   */\n  if (url.protocol === 'file:') {\n    return\n  }\n\n  applyStrategy(strategy)\n}\n", "\"use strict\";\n\nvar defaultParseOptions = {\n  decodeValues: true,\n  map: false,\n  silent: false,\n};\n\nfunction isNonEmptyString(str) {\n  return typeof str === \"string\" && !!str.trim();\n}\n\nfunction parseString(setCookieValue, options) {\n  var parts = setCookieValue.split(\";\").filter(isNonEmptyString);\n\n  var nameValuePairStr = parts.shift();\n  var parsed = parseNameValuePair(nameValuePairStr);\n  var name = parsed.name;\n  var value = parsed.value;\n\n  options = options\n    ? Object.assign({}, defaultParseOptions, options)\n    : defaultParseOptions;\n\n  try {\n    value = options.decodeValues ? decodeURIComponent(value) : value; // decode cookie value\n  } catch (e) {\n    console.error(\n      \"set-cookie-parser encountered an error while decoding a cookie with value '\" +\n        value +\n        \"'. Set options.decodeValues to false to disable this feature.\",\n      e\n    );\n  }\n\n  var cookie = {\n    name: name,\n    value: value,\n  };\n\n  parts.forEach(function (part) {\n    var sides = part.split(\"=\");\n    var key = sides.shift().trimLeft().toLowerCase();\n    var value = sides.join(\"=\");\n    if (key === \"expires\") {\n      cookie.expires = new Date(value);\n    } else if (key === \"max-age\") {\n      cookie.maxAge = parseInt(value, 10);\n    } else if (key === \"secure\") {\n      cookie.secure = true;\n    } else if (key === \"httponly\") {\n      cookie.httpOnly = true;\n    } else if (key === \"samesite\") {\n      cookie.sameSite = value;\n    } else {\n      cookie[key] = value;\n    }\n  });\n\n  return cookie;\n}\n\nfunction parseNameValuePair(nameValuePairStr) {\n  // Parses name-value-pair according to rfc6265bis draft\n\n  var name = \"\";\n  var value = \"\";\n  var nameValueArr = nameValuePairStr.split(\"=\");\n  if (nameValueArr.length > 1) {\n    name = nameValueArr.shift();\n    value = nameValueArr.join(\"=\"); // everything after the first =, joined by a \"=\" if there was more than one part\n  } else {\n    value = nameValuePairStr;\n  }\n\n  return { name: name, value: value };\n}\n\nfunction parse(input, options) {\n  options = options\n    ? Object.assign({}, defaultParseOptions, options)\n    : defaultParseOptions;\n\n  if (!input) {\n    if (!options.map) {\n      return [];\n    } else {\n      return {};\n    }\n  }\n\n  if (input.headers) {\n    if (typeof input.headers.getSetCookie === \"function\") {\n      // for fetch responses - they combine headers of the same type in the headers array,\n      // but getSetCookie returns an uncombined array\n      input = input.headers.getSetCookie();\n    } else if (input.headers[\"set-cookie\"]) {\n      // fast-path for node.js (which automatically normalizes header names to lower-case\n      input = input.headers[\"set-cookie\"];\n    } else {\n      // slow-path for other environments - see #25\n      var sch =\n        input.headers[\n          Object.keys(input.headers).find(function (key) {\n            return key.toLowerCase() === \"set-cookie\";\n          })\n        ];\n      // warn if called on a request-like object with a cookie header rather than a set-cookie header - see #34, 36\n      if (!sch && input.headers.cookie && !options.silent) {\n        console.warn(\n          \"Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.\"\n        );\n      }\n      input = sch;\n    }\n  }\n  if (!Array.isArray(input)) {\n    input = [input];\n  }\n\n  options = options\n    ? Object.assign({}, defaultParseOptions, options)\n    : defaultParseOptions;\n\n  if (!options.map) {\n    return input.filter(isNonEmptyString).map(function (str) {\n      return parseString(str, options);\n    });\n  } else {\n    var cookies = {};\n    return input.filter(isNonEmptyString).reduce(function (cookies, str) {\n      var cookie = parseString(str, options);\n      cookies[cookie.name] = cookie;\n      return cookies;\n    }, cookies);\n  }\n}\n\n/*\n  Set-Cookie header field-values are sometimes comma joined in one string. This splits them without choking on commas\n  that are within a single set-cookie field-value, such as in the Expires portion.\n\n  This is uncommon, but explicitly allowed - see https://tools.ietf.org/html/rfc2616#section-4.2\n  Node.js does this for every header *except* set-cookie - see https://github.com/nodejs/node/blob/d5e363b77ebaf1caf67cd7528224b651c86815c1/lib/_http_incoming.js#L128\n  React Native's fetch does this for *every* header, including set-cookie.\n\n  Based on: https://github.com/google/j2objc/commit/16820fdbc8f76ca0c33472810ce0cb03d20efe25\n  Credits to: https://github.com/tomball for original and https://github.com/chrusart for JavaScript implementation\n*/\nfunction splitCookiesString(cookiesString) {\n  if (Array.isArray(cookiesString)) {\n    return cookiesString;\n  }\n  if (typeof cookiesString !== \"string\") {\n    return [];\n  }\n\n  var cookiesStrings = [];\n  var pos = 0;\n  var start;\n  var ch;\n  var lastComma;\n  var nextStart;\n  var cookiesSeparatorFound;\n\n  function skipWhitespace() {\n    while (pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))) {\n      pos += 1;\n    }\n    return pos < cookiesString.length;\n  }\n\n  function notSpecialChar() {\n    ch = cookiesString.charAt(pos);\n\n    return ch !== \"=\" && ch !== \";\" && ch !== \",\";\n  }\n\n  while (pos < cookiesString.length) {\n    start = pos;\n    cookiesSeparatorFound = false;\n\n    while (skipWhitespace()) {\n      ch = cookiesString.charAt(pos);\n      if (ch === \",\") {\n        // ',' is a cookie separator if we have later first '=', not ';' or ','\n        lastComma = pos;\n        pos += 1;\n\n        skipWhitespace();\n        nextStart = pos;\n\n        while (pos < cookiesString.length && notSpecialChar()) {\n          pos += 1;\n        }\n\n        // currently special character\n        if (pos < cookiesString.length && cookiesString.charAt(pos) === \"=\") {\n          // we found cookies separator\n          cookiesSeparatorFound = true;\n          // pos is inside the next cookie, so back up and return it.\n          pos = nextStart;\n          cookiesStrings.push(cookiesString.substring(start, lastComma));\n          start = pos;\n        } else {\n          // in param ',' or param separator ';',\n          // we continue from that comma\n          pos = lastComma + 1;\n        }\n      } else {\n        pos += 1;\n      }\n    }\n\n    if (!cookiesSeparatorFound || pos >= cookiesString.length) {\n      cookiesStrings.push(cookiesString.substring(start, cookiesString.length));\n    }\n  }\n\n  return cookiesStrings;\n}\n\nmodule.exports = parse;\nmodule.exports.parse = parse;\nmodule.exports.parseString = parseString;\nmodule.exports.splitCookiesString = splitCookiesString;\n", "import { Cookie, parse as parseCookie } from 'set-cookie-parser'\n\ninterface RequestLike {\n  credentials: Request['credentials']\n  url: string\n}\n\ninterface HeadersLike {\n  get(name: string): string | null\n}\n\ninterface ResponseLike {\n  headers: HeadersLike\n}\n\nexport type Store = Map<string, StoreEntry>\nexport type StoreEntry = Map<string, Cookie>\nexport type CookieString = Omit<Cookie, 'expires'> & { expires?: string }\n\nexport const PERSISTENCY_KEY = 'MSW_COOKIE_STORE'\n\nfunction supportsLocalStorage() {\n  try {\n    if (localStorage == null) {\n      return false\n    }\n\n    const testKey = PERSISTENCY_KEY + '_test'\n\n    localStorage.setItem(testKey, 'test')\n    localStorage.getItem(testKey)\n    localStorage.removeItem(testKey)\n\n    return true\n  } catch (error) {\n    return false\n  }\n}\n\n/**\n * Checks that accessing a given property on an object\n * by name does not throw an error.\n *\n * This is generally used to avoid issues in environments\n * like `miniflare` where some properties are defined as getters\n * where accessing that property throws directly.\n */\nfunction isPropertyAccessible<Obj extends Record<string, any>>(\n  object: Obj,\n  method: keyof Obj,\n) {\n  try {\n    object[method]\n    return true\n  } catch {\n    return false\n  }\n}\n\nclass CookieStore {\n  private store: Store\n\n  constructor() {\n    this.store = new Map()\n  }\n\n  /**\n   * Sets the given request cookies into the store.\n   * Respects the `request.credentials` policy.\n   */\n  add(request: RequestLike, response: ResponseLike): void {\n    if (\n      isPropertyAccessible(request, 'credentials') &&\n      request.credentials === 'omit'\n    ) {\n      return\n    }\n\n    const requestUrl = new URL(request.url)\n    const responseCookies = response.headers.get('set-cookie')\n\n    if (!responseCookies) {\n      return\n    }\n\n    const now = Date.now()\n    const parsedResponseCookies = parseCookie(responseCookies).map(\n      ({ maxAge, ...cookie }) => ({\n        ...cookie,\n        expires:\n          maxAge === undefined ? cookie.expires : new Date(now + maxAge * 1000),\n        maxAge,\n      }),\n    )\n\n    const prevCookies =\n      this.store.get(requestUrl.origin) || new Map<string, Cookie>()\n\n    parsedResponseCookies.forEach((cookie) => {\n      this.store.set(requestUrl.origin, prevCookies.set(cookie.name, cookie))\n    })\n  }\n\n  /**\n   * Returns cookies relevant to the given request\n   * and its `request.credentials` policy.\n   */\n  get(request: RequestLike): StoreEntry {\n    this.deleteExpiredCookies()\n\n    const requestUrl = new URL(request.url)\n    const originCookies =\n      this.store.get(requestUrl.origin) || new Map<string, Cookie>()\n\n    if (!isPropertyAccessible(request, 'credentials')) {\n      return originCookies\n    }\n\n    switch (request.credentials) {\n      case 'include': {\n        // Support running this method in Node.js.\n        if (typeof document === 'undefined') {\n          return originCookies\n        }\n\n        const documentCookies = parseCookie(document.cookie)\n\n        documentCookies.forEach((cookie) => {\n          originCookies.set(cookie.name, cookie)\n        })\n\n        return originCookies\n      }\n\n      case 'same-origin': {\n        return originCookies\n      }\n\n      default:\n        return new Map()\n    }\n  }\n\n  /**\n   * Returns a collection of all stored cookies.\n   */\n  getAll(): Store {\n    this.deleteExpiredCookies()\n    return this.store\n  }\n\n  /**\n   * Deletes all cookies associated with the given request.\n   */\n  deleteAll(request: RequestLike): void {\n    const requestUrl = new URL(request.url)\n    this.store.delete(requestUrl.origin)\n  }\n\n  /**\n   * Clears the entire cookie store.\n   */\n  clear(): void {\n    this.store.clear()\n  }\n\n  /**\n   * Hydrates the virtual cookie store from the `localStorage` if defined.\n   */\n  hydrate(): void {\n    if (!supportsLocalStorage()) {\n      return\n    }\n\n    const persistedCookies = localStorage.getItem(PERSISTENCY_KEY)\n\n    if (!persistedCookies) {\n      return\n    }\n\n    try {\n      const parsedCookies: [string, [string, CookieString][]][] =\n        JSON.parse(persistedCookies)\n\n      parsedCookies.forEach(([origin, cookies]) => {\n        this.store.set(\n          origin,\n          new Map(\n            cookies.map(([token, { expires, ...cookie }]) => [\n              token,\n              expires === undefined\n                ? cookie\n                : { ...cookie, expires: new Date(expires) },\n            ]),\n          ),\n        )\n      })\n    } catch (error) {\n      console.warn(`\n[virtual-cookie] Failed to parse a stored cookie from the localStorage (key \"${PERSISTENCY_KEY}\").\n\nStored value:\n${localStorage.getItem(PERSISTENCY_KEY)}\n\nThrown exception:\n${error}\n\nInvalid value has been removed from localStorage to prevent subsequent failed parsing attempts.`)\n      localStorage.removeItem(PERSISTENCY_KEY)\n    }\n  }\n\n  /**\n   * Persists the current virtual cookies into the `localStorage` if defined,\n   * so they are available on the next page load.\n   */\n  persist(): void {\n    if (!supportsLocalStorage()) {\n      return\n    }\n\n    const serializedCookies = Array.from(this.store.entries()).map(\n      ([origin, cookies]) => {\n        return [origin, Array.from(cookies.entries())]\n      },\n    )\n\n    localStorage.setItem(PERSISTENCY_KEY, JSON.stringify(serializedCookies))\n  }\n\n  private deleteExpiredCookies() {\n    const now = Date.now()\n\n    this.store.forEach((originCookies, origin) => {\n      originCookies.forEach(({ expires, name }) => {\n        if (expires !== undefined && expires.getTime() <= now) {\n          originCookies.delete(name)\n        }\n      })\n\n      if (originCookies.size === 0) {\n        this.store.delete(origin)\n      }\n    })\n  }\n}\n\nexport const store = new CookieStore()\n", "import { store } from '@mswjs/cookies'\n\nexport function readResponseCookies(\n  request: Request,\n  response: Response,\n): void {\n  store.add({ ...request, url: request.url.toString() }, response)\n  store.persist()\n}\n", "import { until } from '@open-draft/until'\nimport { Emitter } from 'strict-event-emitter'\nimport { RequestHandler } from '../handlers/RequestHandler'\nimport { LifeCycleEventsMap, SharedOptions } from '../sharedOptions'\nimport { RequiredDeep } from '../typeUtils'\nimport { HandlersExecutionResult, executeHandlers } from './executeHandlers'\nimport { onUnhandledRequest } from './request/onUnhandledRequest'\nimport { readResponseCookies } from './request/readResponseCookies'\n\nexport interface HandleRequestOptions {\n  /**\n   * `resolutionContext` is not part of the general public api\n   * but is exposed to aid in creating extensions like\n   * `@mswjs/http-middleware`.\n   */\n  resolutionContext?: {\n    /**\n     * A base url to use when resolving relative urls.\n     * @note This is primarily used by the `@mswjs/http-middleware`\n     * to resolve relative urls in the context of the running server\n     */\n    baseUrl?: string\n  }\n\n  /**\n   * Transforms a `MockedResponse` instance returned from a handler\n   * to a response instance supported by the lower tooling (i.e. interceptors).\n   */\n  transformResponse?(response: Response): Response\n\n  /**\n   * Invoked whenever a request is performed as-is.\n   */\n  onPassthroughResponse?(request: Request): void\n\n  /**\n   * Invoked when the mocked response is ready to be sent.\n   */\n  onMockedResponse?(\n    response: Response,\n    handler: RequiredDeep<HandlersExecutionResult>,\n  ): void\n}\n\nexport async function handleRequest(\n  request: Request,\n  requestId: string,\n  handlers: Array<RequestHandler>,\n  options: RequiredDeep<SharedOptions>,\n  emitter: Emitter<LifeCycleEventsMap>,\n  handleRequestOptions?: HandleRequestOptions,\n): Promise<Response | undefined> {\n  emitter.emit('request:start', { request, requestId })\n\n  // Perform bypassed requests (i.e. wrapped in \"bypass()\") as-is.\n  if (request.headers.get('x-msw-intention') === 'bypass') {\n    emitter.emit('request:end', { request, requestId })\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Resolve a mocked response from the list of request handlers.\n  const lookupResult = await until(() => {\n    return executeHandlers({\n      request,\n      requestId,\n      handlers,\n      resolutionContext: handleRequestOptions?.resolutionContext,\n    })\n  })\n\n  if (lookupResult.error) {\n    // Allow developers to react to unhandled exceptions in request handlers.\n    emitter.emit('unhandledException', {\n      error: lookupResult.error,\n      request,\n      requestId,\n    })\n    throw lookupResult.error\n  }\n\n  // If the handler lookup returned nothing, no request handler was found\n  // matching this request. Report the request as unhandled.\n  if (!lookupResult.data) {\n    await onUnhandledRequest(request, options.onUnhandledRequest)\n    emitter.emit('request:unhandled', { request, requestId })\n    emitter.emit('request:end', { request, requestId })\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  const { response } = lookupResult.data\n\n  // When the handled request returned no mocked response, warn the developer,\n  // as it may be an oversight on their part. Perform the request as-is.\n  if (!response) {\n    emitter.emit('request:end', { request, requestId })\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Perform the request as-is when the developer explicitly returned \"req.passthrough()\".\n  // This produces no warning as the request was handled.\n  if (\n    response.status === 302 &&\n    response.headers.get('x-msw-intention') === 'passthrough'\n  ) {\n    emitter.emit('request:end', { request, requestId })\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Store all the received response cookies in the virtual cookie store.\n  readResponseCookies(request, response)\n\n  emitter.emit('request:match', { request, requestId })\n\n  const requiredLookupResult =\n    lookupResult.data as RequiredDeep<HandlersExecutionResult>\n\n  const transformedResponse =\n    handleRequestOptions?.transformResponse?.(response) ||\n    (response as any as Response)\n\n  handleRequestOptions?.onMockedResponse?.(\n    transformedResponse,\n    requiredLookupResult,\n  )\n\n  emitter.emit('request:end', { request, requestId })\n\n  return transformedResponse\n}\n", "export function toResponseInit(response: Response): ResponseInit {\n  return {\n    status: response.status,\n    statusText: response.statusText,\n    headers: Object.fromEntries(response.headers.entries()),\n  }\n}\n", "/**\n * Determines if the given value is an object.\n */\nexport function isObject(value: any): boolean {\n  return value != null && typeof value === 'object' && !Array.isArray(value)\n}\n", "import { isObject } from './isObject'\n\n/**\n * Deeply merges two given objects with the right one\n * having a priority during property assignment.\n */\nexport function mergeRight(\n  left: Record<string, any>,\n  right: Record<string, any>,\n) {\n  return Object.entries(right).reduce(\n    (result, [key, rightValue]) => {\n      const leftValue = result[key]\n\n      if (Array.isArray(leftValue) && Array.isArray(rightValue)) {\n        result[key] = leftValue.concat(rightValue)\n        return result\n      }\n\n      if (isObject(leftValue) && isObject(rightValue)) {\n        result[key] = mergeRight(leftValue, rightValue)\n        return result\n      }\n\n      result[key] = rightValue\n      return result\n    },\n    Object.assign({}, left),\n  )\n}\n", "export * from './Emitter'\nexport * from './MemoryLeakError'\n", "import type { Emitter } from './Emitter'\n\nexport class MemoryLeakError extends Error {\n  constructor(\n    public readonly emitter: Emitter<any>,\n    public readonly type: string | number | symbol,\n    public readonly count: number\n  ) {\n    super(\n      `Possible EventEmitter memory leak detected. ${count} ${type.toString()} listeners added. Use emitter.setMaxListeners() to increase limit`\n    )\n    this.name = 'MaxListenersExceededWarning'\n  }\n}\n", "import { MemoryLeakError } from './MemoryLeakError'\n\nexport type EventMap = {\n  [eventName: string]: Array<unknown>\n}\n\nexport type InternalEventNames = 'newListener' | 'removeListener'\n\nexport type InternalListener<Events extends EventMap> = Listener<\n  [eventName: keyof Events, listener: Listener<Array<unknown>>]\n>\n\nexport type Listener<Data extends Array<unknown>> = (...data: Data) => void\n\n/**\n * Node.js-compatible implementation of `EventEmitter`.\n *\n * @example\n * const emitter = new Emitter<{ hello: [string] }>()\n * emitter.on('hello', (name) => console.log(name))\n * emitter.emit('hello', 'John')\n */\nexport class Emitter<Events extends EventMap> {\n  private events: Map<keyof Events, Array<Listener<any>>>\n  private maxListeners: number\n  private hasWarnedAboutPotentialMemoryLeak: boolean\n\n  static defaultMaxListeners = 10\n\n  static listenerCount<Events extends EventMap>(\n    emitter: Emitter<EventMap>,\n    eventName: keyof Events\n  ): number {\n    return emitter.listenerCount<any>(eventName)\n  }\n\n  constructor() {\n    this.events = new Map()\n    this.maxListeners = Emitter.defaultMaxListeners\n    this.hasWarnedAboutPotentialMemoryLeak = false\n  }\n\n  private _emitInternalEvent(\n    internalEventName: InternalEventNames,\n    eventName: keyof Events,\n    listener: Listener<Array<unknown>>\n  ): void {\n    this.emit(\n      internalEventName,\n      // Anything to make TypeScript happy.\n      ...([eventName, listener] as Events['newListener'] &\n        Events['removeListener'])\n    )\n  }\n\n  private _getListeners<EventName extends keyof Events>(\n    eventName: EventName\n  ): Array<Listener<Array<unknown>>> {\n    // Always return a copy of the listeners array\n    // so they are fixed at the time of the \"_getListeners\" call.\n    return Array.prototype.concat.apply([], this.events.get(eventName)) || []\n  }\n\n  private _removeListener<EventName extends keyof Events>(\n    listeners: Array<Listener<Events[EventName]>>,\n    listener: Listener<Events[EventName]>\n  ): Array<Listener<Events[EventName]>> {\n    const index = listeners.indexOf(listener)\n\n    if (index > -1) {\n      listeners.splice(index, 1)\n    }\n\n    return []\n  }\n\n  private _wrapOnceListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): Listener<Events[EventName]> {\n    const onceListener = (...data: Events[keyof Events]) => {\n      this.removeListener(eventName, onceListener)\n\n      /**\n       * @note Return the result of the original listener.\n       * This way this wrapped preserves listeners that are async.\n       */\n      return listener.apply(this, data)\n    }\n\n    // Inherit the name of the original listener.\n    Object.defineProperty(onceListener, 'name', { value: listener.name })\n\n    return onceListener\n  }\n\n  public setMaxListeners(maxListeners: number): this {\n    this.maxListeners = maxListeners\n    return this\n  }\n\n  /**\n   * Returns the current max listener value for the `Emitter` which is\n   * either set by `emitter.setMaxListeners(n)` or defaults to\n   * `Emitter.defaultMaxListeners`.\n   */\n  public getMaxListeners(): number {\n    return this.maxListeners\n  }\n\n  /**\n   * Returns an array listing the events for which the emitter has registered listeners.\n   * The values in the array will be strings or Symbols.\n   */\n  public eventNames(): Array<keyof Events> {\n    return Array.from(this.events.keys())\n  }\n\n  /**\n   * Synchronously calls each of the listeners registered for the event named `eventName`,\n   * in the order they were registered, passing the supplied arguments to each.\n   * Returns `true` if the event has listeners, `false` otherwise.\n   *\n   * @example\n   * const emitter = new Emitter<{ hello: [string] }>()\n   * emitter.emit('hello', 'John')\n   */\n  public emit<EventName extends keyof Events>(\n    eventName: EventName,\n    ...data: Events[EventName]\n  ): boolean {\n    const listeners = this._getListeners(eventName)\n    listeners.forEach((listener) => {\n      listener.apply(this, data)\n    })\n\n    return listeners.length > 0\n  }\n\n  public addListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public addListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public addListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: InternalListener<Events> | Listener<Events[any]>\n  ): this {\n    // Emit the `newListener` event before adding the listener.\n    this._emitInternalEvent('newListener', eventName, listener)\n\n    const nextListeners = this._getListeners(eventName).concat(listener)\n    this.events.set(eventName, nextListeners)\n\n    if (\n      this.maxListeners > 0 &&\n      this.listenerCount(eventName) > this.maxListeners &&\n      !this.hasWarnedAboutPotentialMemoryLeak\n    ) {\n      this.hasWarnedAboutPotentialMemoryLeak = true\n\n      const memoryLeakWarning = new MemoryLeakError(\n        this,\n        eventName,\n        this.listenerCount(eventName)\n      )\n      console.warn(memoryLeakWarning)\n    }\n\n    return this\n  }\n\n  public on(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public on<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public on<EventName extends keyof Events>(\n    eventName: 'removeListener' | EventName,\n    listener: Listener<any>\n  ): this {\n    return this.addListener(eventName, listener)\n  }\n\n  public once(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public once<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public once<EventName extends keyof Events>(\n    eventName: InternalEventNames | EventName,\n    listener: Listener<any>\n  ): this {\n    return this.addListener(\n      eventName,\n      this._wrapOnceListener(eventName, listener)\n    )\n  }\n\n  public prependListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public prependListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public prependListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    const listeners = this._getListeners(eventName)\n\n    if (listeners.length > 0) {\n      const nextListeners = [listener].concat(listeners)\n      this.events.set(eventName, nextListeners)\n    } else {\n      this.events.set(eventName, listeners.concat(listener))\n    }\n\n    return this\n  }\n\n  public prependOnceListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public prependOnceListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public prependOnceListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    return this.prependListener(\n      eventName,\n      this._wrapOnceListener(eventName, listener)\n    )\n  }\n\n  public removeListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public removeListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public removeListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    const listeners = this._getListeners(eventName)\n\n    if (listeners.length > 0) {\n      this._removeListener(listeners, listener)\n      this.events.set(eventName, listeners)\n\n      // Emit the `removeListener` event after removing the listener.\n      this._emitInternalEvent('removeListener', eventName, listener)\n    }\n\n    return this\n  }\n\n  public off(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public off<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  /**\n   * Alias for `emitter.removeListener()`.\n   *\n   * @example\n   * emitter.off('hello', listener)\n   */\n  public off(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    return this.removeListener(eventName, listener)\n  }\n\n  public removeAllListeners(eventName?: InternalEventNames): this\n  public removeAllListeners<EventName extends keyof Events>(\n    eventName?: EventName\n  ): this\n  public removeAllListeners(\n    eventName?: InternalEventNames | keyof Events\n  ): this {\n    if (eventName) {\n      this.events.delete(eventName)\n    } else {\n      this.events.clear()\n    }\n\n    return this\n  }\n\n  public listeners(eventName: InternalEventNames): Array<Listener<any>>\n  public listeners<EventName extends keyof Events>(\n    eventName: EventName\n  ): Array<Listener<Events[EventName]>>\n  /**\n   * Returns a copy of the array of listeners for the event named `eventName`.\n   */\n  public listeners(eventName: InternalEventNames | keyof Events) {\n    return Array.from(this._getListeners(eventName))\n  }\n\n  public listenerCount(eventName: InternalEventNames): number\n  public listenerCount<EventName extends keyof Events>(\n    eventName: EventName\n  ): number\n  /**\n   * Returns the number of listeners listening to the event named `eventName`.\n   */\n  public listenerCount(eventName: InternalEventNames | keyof Events): number {\n    return this._getListeners(eventName).length\n  }\n\n  public rawListeners<EventName extends keyof Events>(\n    eventName: EventName\n  ): Array<Listener<Events[EventName]>> {\n    return this.listeners(eventName)\n  }\n}\n", "import { Emitter, EventMap } from 'strict-event-emitter'\n\n/**\n * Pipes all emitted events from one emitter to another.\n */\nexport function pipeEvents<Events extends EventMap>(\n  source: Emitter<Events>,\n  destination: Emitter<Events>,\n): void {\n  const rawEmit: typeof source.emit & { _isPiped?: boolean } = source.emit\n\n  if (rawEmit._isPiped) {\n    return\n  }\n\n  const sourceEmit: typeof source.emit & { _isPiped?: boolean } =\n    function sourceEmit(this: typeof source, event, ...data) {\n      destination.emit(event, ...data)\n      return rawEmit.call(this, event, ...data)\n    }\n\n  sourceEmit._isPiped = true\n\n  source.emit = sourceEmit\n}\n", "/**\n * Creates an immutable copy of the given array.\n */\nexport function toReadonlyArray<T>(source: Array<T>): ReadonlyArray<T> {\n  const clone = [...source] as Array<T>\n  Object.freeze(clone)\n  return clone\n}\n", "export type DisposableSubscription = () => Promise<void> | void\n\nexport class Disposable {\n  protected subscriptions: Array<DisposableSubscription> = []\n\n  public async dispose() {\n    await Promise.all(this.subscriptions.map((subscription) => subscription()))\n  }\n}\n", "import { invariant } from 'outvariant'\nimport { EventMap, Emitter } from 'strict-event-emitter'\nimport {\n  RequestHandler,\n  RequestHandlerDefaultInfo,\n} from './handlers/RequestHandler'\nimport { LifeCycleEventEmitter } from './sharedOptions'\nimport { devUtils } from './utils/internal/devUtils'\nimport { pipeEvents } from './utils/internal/pipeEvents'\nimport { toReadonlyArray } from './utils/internal/toReadonlyArray'\nimport { Disposable } from './utils/internal/Disposable'\n\nexport abstract class HandlersController {\n  abstract prepend(runtimeHandlers: Array<RequestHandler>): void\n  abstract reset(nextHandles: Array<RequestHandler>): void\n  abstract currentHandlers(): Array<RequestHandler>\n}\n\nexport class InMemoryHandlersController implements HandlersController {\n  private handlers: Array<RequestHandler>\n\n  constructor(private initialHandlers: Array<RequestHandler>) {\n    this.handlers = [...initialHandlers]\n  }\n\n  public prepend(runtimeHandles: Array<RequestHandler>): void {\n    this.handlers.unshift(...runtimeHandles)\n  }\n\n  public reset(nextHandlers: Array<RequestHandler>): void {\n    this.handlers =\n      nextHandlers.length > 0 ? [...nextHandlers] : [...this.initialHandlers]\n  }\n\n  public currentHandlers(): Array<RequestHandler> {\n    return this.handlers\n  }\n}\n\n/**\n * Generic class for the mock API setup.\n */\nexport abstract class SetupApi<EventsMap extends EventMap> extends Disposable {\n  protected handlersController: HandlersController\n  protected readonly emitter: Emitter<EventsMap>\n  protected readonly publicEmitter: Emitter<EventsMap>\n\n  public readonly events: LifeCycleEventEmitter<EventsMap>\n\n  constructor(...initialHandlers: Array<RequestHandler>) {\n    super()\n\n    invariant(\n      this.validateHandlers(initialHandlers),\n      devUtils.formatMessage(\n        `Failed to apply given request handlers: invalid input. Did you forget to spread the request handlers Array?`,\n      ),\n    )\n\n    this.handlersController = new InMemoryHandlersController(initialHandlers)\n\n    this.emitter = new Emitter<EventsMap>()\n    this.publicEmitter = new Emitter<EventsMap>()\n    pipeEvents(this.emitter, this.publicEmitter)\n\n    this.events = this.createLifeCycleEvents()\n\n    this.subscriptions.push(() => {\n      this.emitter.removeAllListeners()\n      this.publicEmitter.removeAllListeners()\n    })\n  }\n\n  private validateHandlers(handlers: ReadonlyArray<RequestHandler>): boolean {\n    // Guard against incorrect call signature of the setup API.\n    return handlers.every((handler) => !Array.isArray(handler))\n  }\n\n  public use(...runtimeHandlers: Array<RequestHandler>): void {\n    invariant(\n      this.validateHandlers(runtimeHandlers),\n      devUtils.formatMessage(\n        `Failed to call \"use()\" with the given request handlers: invalid input. Did you forget to spread the array of request handlers?`,\n      ),\n    )\n\n    this.handlersController.prepend(runtimeHandlers)\n  }\n\n  public restoreHandlers(): void {\n    this.handlersController.currentHandlers().forEach((handler) => {\n      handler.isUsed = false\n    })\n  }\n\n  public resetHandlers(...nextHandlers: Array<RequestHandler>): void {\n    this.handlersController.reset(nextHandlers)\n  }\n\n  public listHandlers(): ReadonlyArray<\n    RequestHandler<RequestHandlerDefaultInfo, any, any>\n  > {\n    return toReadonlyArray(this.handlersController.currentHandlers())\n  }\n\n  private createLifeCycleEvents(): LifeCycleEventEmitter<EventsMap> {\n    return {\n      on: (...args: any[]) => {\n        return (this.publicEmitter.on as any)(...args)\n      },\n      removeListener: (...args: any[]) => {\n        return (this.publicEmitter.removeListener as any)(...args)\n      },\n      removeAllListeners: (...args: any[]) => {\n        return this.publicEmitter.removeAllListeners(...args)\n      },\n    }\n  }\n}\n", "export { setupWorker } from './setupWorker/setupWorker'\nexport type { SetupWorker, StartOptions } from './setupWorker/glossary'\nexport { SetupWorkerApi } from './setupWorker/setupWorker'\n", "const POSITIONALS_EXP = /(%?)(%([sdijo]))/g\n\nfunction serializePositional(positional: any, flag: string): any {\n  switch (flag) {\n    // Strings.\n    case 's':\n      return positional\n\n    // Digits.\n    case 'd':\n    case 'i':\n      return Number(positional)\n\n    // JSON.\n    case 'j':\n      return JSON.stringify(positional)\n\n    // Objects.\n    case 'o': {\n      // Preserve stings to prevent extra quotes around them.\n      if (typeof positional === 'string') {\n        return positional\n      }\n\n      const json = JSON.stringify(positional)\n\n      // If the positional isn't serializable, return it as-is.\n      if (json === '{}' || json === '[]' || /^\\[object .+?\\]$/.test(json)) {\n        return positional\n      }\n\n      return json\n    }\n  }\n}\n\nexport function format(message: string, ...positionals: any[]): string {\n  if (positionals.length === 0) {\n    return message\n  }\n\n  let positionalIndex = 0\n  let formattedMessage = message.replace(\n    POSITIONALS_EXP,\n    (match, isEscaped, _, flag) => {\n      const positional = positionals[positionalIndex]\n      const value = serializePositional(positional, flag)\n\n      if (!isEscaped) {\n        positionalIndex++\n        return value\n      }\n\n      return match\n    }\n  )\n\n  // Append unresolved positionals to string as-is.\n  if (positionalIndex < positionals.length) {\n    formattedMessage += ` ${positionals.slice(positionalIndex).join(' ')}`\n  }\n\n  formattedMessage = formattedMessage.replace(/%{2,2}/g, '%')\n\n  return formattedMessage\n}\n", "import { format } from './format'\n\nconst STACK_FRAMES_TO_IGNORE = 2\n\n/**\n * Remove the \"outvariant\" package trace from the given error.\n * This scopes down the error stack to the relevant parts\n * when used in other applications.\n */\nfunction cleanErrorStack(error: Error): void {\n  if (!error.stack) {\n    return\n  }\n\n  const nextStack = error.stack.split('\\n')\n  nextStack.splice(1, STACK_FRAMES_TO_IGNORE)\n  error.stack = nextStack.join('\\n')\n}\n\nexport class InvariantError extends Error {\n  name = 'Invariant Violation'\n\n  constructor(public readonly message: string, ...positionals: any[]) {\n    super(message)\n    this.message = format(message, ...positionals)\n    cleanErrorStack(this)\n  }\n}\n\nexport interface CustomErrorConstructor {\n  new (message: string): Error\n}\n\nexport interface CustomErrorFactory {\n  (message: string): Error\n}\n\nexport type CustomError = CustomErrorConstructor | CustomErrorFactory\n\ntype Invariant = {\n  (\n    predicate: unknown,\n    message: string,\n    ...positionals: any[]\n  ): asserts predicate\n\n  as(\n    ErrorConstructor: CustomError,\n    predicate: unknown,\n    message: string,\n    ...positionals: unknown[]\n  ): asserts predicate\n}\n\nexport const invariant: Invariant = (\n  predicate,\n  message,\n  ...positionals\n): asserts predicate => {\n  if (!predicate) {\n    throw new InvariantError(message, ...positionals)\n  }\n}\n\ninvariant.as = (ErrorConstructor, predicate, message, ...positionals) => {\n  if (!predicate) {\n    const formatMessage = positionals.length === 0 ? message : format(message, positionals);\n    let error: Error;\n\n    try {\n      error = Reflect.construct(ErrorConstructor as CustomErrorConstructor, [formatMessage]);\n    } catch(err) {\n      error = (ErrorConstructor as CustomErrorFactory)(formatMessage);\n    }\n\n    throw error\n  }\n}\n", "/**\n * Determines if the current process is a Node.js process.\n */\nexport function isNodeProcess(): boolean {\n  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\n    return true\n  }\n\n  if (typeof process !== 'undefined') {\n    // Electron (https://www.electronjs.org/docs/latest/api/process#processtype-readonly)\n    const type = (process as any).type\n    if (type === 'renderer' || type === 'worker') {\n      return false\n    }\n\n\n    return !!(\n      process.versions &&\n      process.versions.node\n    )\n  }\n\n  return false\n}\n", "import { devUtils } from '~/core/utils/internal/devUtils'\nimport { getWorkerInstance } from './utils/getWorkerInstance'\nimport { enableMocking } from './utils/enableMocking'\nimport { SetupWorkerInternalContext, StartHandler } from '../glossary'\nimport { createRequestListener } from './createRequestListener'\nimport { checkWorkerIntegrity } from '../../utils/checkWorkerIntegrity'\nimport { createResponseListener } from './createResponseListener'\nimport { validateWorkerScope } from './utils/validateWorkerScope'\n\nexport const createStartHandler = (\n  context: SetupWorkerInternalContext,\n): StartHandler => {\n  return function start(options, customOptions) {\n    const startWorkerInstance = async () => {\n      // Remove all previously existing event listeners.\n      // This way none of the listeners persists between Fast refresh\n      // of the application's code.\n      context.events.removeAllListeners()\n\n      // Handle requests signaled by the worker.\n      context.workerChannel.on(\n        'REQUEST',\n        createRequestListener(context, options),\n      )\n\n      // Handle responses signaled by the worker.\n      context.workerChannel.on('RESPONSE', createResponseListener(context))\n\n      const instance = await getWorkerInstance(\n        options.serviceWorker.url,\n        options.serviceWorker.options,\n        options.findWorker,\n      )\n\n      const [worker, registration] = instance\n\n      if (!worker) {\n        const missingWorkerMessage = customOptions?.findWorker\n          ? devUtils.formatMessage(\n              `Failed to locate the Service Worker registration using a custom \"findWorker\" predicate.\n\nPlease ensure that the custom predicate properly locates the Service Worker registration at \"%s\".\nMore details: https://mswjs.io/docs/api/setup-worker/start#findworker\n`,\n              options.serviceWorker.url,\n            )\n          : devUtils.formatMessage(\n              `Failed to locate the Service Worker registration.\n\nThis most likely means that the worker script URL \"%s\" cannot resolve against the actual public hostname (%s). This may happen if your application runs behind a proxy, or has a dynamic hostname.\n\nPlease consider using a custom \"serviceWorker.url\" option to point to the actual worker script location, or a custom \"findWorker\" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start`,\n              options.serviceWorker.url,\n              location.host,\n            )\n\n        throw new Error(missingWorkerMessage)\n      }\n\n      context.worker = worker\n      context.registration = registration\n\n      context.events.addListener(window, 'beforeunload', () => {\n        if (worker.state !== 'redundant') {\n          // Notify the Service Worker that this client has closed.\n          // Internally, it's similar to disabling the mocking, only\n          // client close event has a handler that self-terminates\n          // the Service Worker when there are no open clients.\n          context.workerChannel.send('CLIENT_CLOSED')\n        }\n        // Make sure we're always clearing the interval - there are reports that not doing this can\n        // cause memory leaks in headless browser environments.\n        window.clearInterval(context.keepAliveInterval)\n      })\n\n      // Check if the active Service Worker has been generated\n      // by the currently installed version of MSW.\n      await checkWorkerIntegrity(context).catch((error) => {\n        devUtils.error(\n          'Error while checking the worker script integrity. Please report this on GitHub (https://github.com/mswjs/msw/issues), including the original error below.',\n        )\n        console.error(error)\n      })\n\n      context.keepAliveInterval = window.setInterval(\n        () => context.workerChannel.send('KEEPALIVE_REQUEST'),\n        5000,\n      )\n\n      // Warn the user when loading the page that lies outside\n      // of the worker's scope.\n      validateWorkerScope(registration, context.startOptions)\n\n      return registration\n    }\n\n    const workerRegistration = startWorkerInstance().then(\n      async (registration) => {\n        const pendingInstance = registration.installing || registration.waiting\n\n        // Wait until the worker is activated.\n        // Assume the worker is already activated if there's no pending registration\n        // (i.e. when reloading the page after a successful activation).\n        if (pendingInstance) {\n          await new Promise<void>((resolve) => {\n            pendingInstance.addEventListener('statechange', () => {\n              if (pendingInstance.state === 'activated') {\n                return resolve()\n              }\n            })\n          })\n        }\n\n        // Print the activation message only after the worker has been activated.\n        await enableMocking(context, options).catch((error) => {\n          throw new Error(`Failed to enable mocking: ${error?.message}`)\n        })\n\n        return registration\n      },\n    )\n\n    return workerRegistration\n  }\n}\n", "export type AsyncTuple<\n  ErrorType extends any = Error,\n  DataType extends any = unknown,\n> =\n  | {\n      error: ErrorType\n      data: null\n    }\n  | { error: null; data: DataType }\n\n/**\n * Gracefully handles a given Promise factory.\n * @example\n * const { error, data } = await until(() => asyncAction())\n */\nexport const until = async <\n  ErrorType extends any = Error,\n  DataType extends any = unknown,\n>(\n  promise: () => Promise<DataType>,\n): Promise<AsyncTuple<ErrorType, DataType>> => {\n  try {\n    const data = await promise().catch((error) => {\n      throw error\n    })\n    return { error: null, data }\n  } catch (error) {\n    return { error, data: null }\n  }\n}\n", "import { until } from '@open-draft/until'\nimport { devUtils } from '~/core/utils/internal/devUtils'\nimport { getAbsoluteWorkerUrl } from '../../../utils/getAbsoluteWorkerUrl'\nimport { getWorkerByRegistration } from './getWorkerByRegistration'\nimport { ServiceWorkerInstanceTuple, FindWorker } from '../../glossary'\n\n/**\n * Returns an active Service Worker instance.\n * When not found, registers a new Service Worker.\n */\nexport const getWorkerInstance = async (\n  url: string,\n  options: RegistrationOptions = {},\n  findWorker: FindWorker,\n): Promise<ServiceWorkerInstanceTuple> => {\n  // Resolve the absolute Service Worker URL.\n  const absoluteWorkerUrl = getAbsoluteWorkerUrl(url)\n\n  const mockRegistrations = await navigator.serviceWorker\n    .getRegistrations()\n    .then((registrations) =>\n      registrations.filter((registration) =>\n        getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker),\n      ),\n    )\n  if (!navigator.serviceWorker.controller && mockRegistrations.length > 0) {\n    // Reload the page when it has associated workers, but no active controller.\n    // The absence of a controller can mean either:\n    // - page has no Service Worker associated with it\n    // - page has been hard-reloaded and its workers won't be used until the next reload.\n    // Since we've checked that there are registrations associated with this page,\n    // at this point we are sure it's hard reload that falls into this clause.\n    location.reload()\n  }\n\n  const [existingRegistration] = mockRegistrations\n\n  if (existingRegistration) {\n    // When the Service Worker is registered, update it and return the reference.\n    return existingRegistration.update().then(() => {\n      return [\n        getWorkerByRegistration(\n          existingRegistration,\n          absoluteWorkerUrl,\n          findWorker,\n        ),\n        existingRegistration,\n      ]\n    })\n  }\n\n  // When the Service Worker wasn't found, register it anew and return the reference.\n  const registrationResult = await until<Error, ServiceWorkerInstanceTuple>(\n    async () => {\n      const registration = await navigator.serviceWorker.register(url, options)\n      return [\n        // Compare existing worker registration by its worker URL,\n        // to prevent irrelevant workers to resolve here (such as Codesandbox worker).\n        getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker),\n        registration,\n      ]\n    },\n  )\n\n  // Handle Service Worker registration errors.\n  if (registrationResult.error) {\n    const isWorkerMissing = registrationResult.error.message.includes('(404)')\n\n    // Produce a custom error message when given a non-existing Service Worker url.\n    // Suggest developers to check their setup.\n    if (isWorkerMissing) {\n      const scopeUrl = new URL(options?.scope || '/', location.href)\n\n      throw new Error(\n        devUtils.formatMessage(`\\\nFailed to register a Service Worker for scope ('${scopeUrl.href}') with script ('${absoluteWorkerUrl}'): Service Worker script does not exist at the given path.\n\nDid you forget to run \"npx msw init <PUBLIC_DIR>\"?\n\nLearn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`),\n      )\n    }\n\n    // Fallback error message for any other registration errors.\n    throw new Error(\n      devUtils.formatMessage(\n        'Failed to register the Service Worker:\\n\\n%s',\n        registrationResult.error.message,\n      ),\n    )\n  }\n\n  return registrationResult.data\n}\n", "/**\n * Returns an absolute Service Worker URL based on the given\n * relative URL (known during the registration).\n */\nexport function getAbsoluteWorkerUrl(workerUrl: string): string {\n  return new URL(workerUrl, location.href).href\n}\n", "import { FindWorker } from '../../glossary'\n\n/**\n * Attempts to resolve a Service Worker instance from a given registration,\n * regardless of its state (active, installing, waiting).\n */\nexport function getWorkerByRegistration(\n  registration: ServiceWorkerRegistration,\n  absoluteWorkerUrl: string,\n  findWorker: FindWorker,\n): ServiceWorker | null {\n  const allStates = [\n    registration.active,\n    registration.installing,\n    registration.waiting,\n  ]\n  const relevantStates = allStates.filter((state): state is ServiceWorker => {\n    return state != null\n  })\n  const worker = relevantStates.find((worker) => {\n    return findWorker(worker.scriptURL, absoluteWorkerUrl)\n  })\n\n  return worker || null\n}\n", "import { devUtils } from '~/core/utils/internal/devUtils'\nimport { StartOptions, SetupWorkerInternalContext } from '../../glossary'\nimport { printStartMessage } from './printStartMessage'\n\n/**\n * Signals the worker to enable the interception of requests.\n */\nexport async function enableMocking(\n  context: SetupWorkerInternalContext,\n  options: StartOptions,\n) {\n  context.workerChannel.send('MOCK_ACTIVATE')\n  await context.events.once('MOCKING_ENABLED')\n\n  // Warn the developer on multiple \"worker.start()\" calls.\n  // While this will not affect the worker in any way,\n  // it likely indicates an issue with the developer's code.\n  if (context.isMockingEnabled) {\n    devUtils.warn(\n      `Found a redundant \"worker.start()\" call. Note that starting the worker while mocking is already enabled will have no effect. Consider removing this \"worker.start()\" call.`,\n    )\n    return\n  }\n\n  context.isMockingEnabled = true\n\n  printStartMessage({\n    quiet: options.quiet,\n    workerScope: context.registration?.scope,\n    workerUrl: context.worker?.scriptURL,\n  })\n}\n", "import { devUtils } from '~/core/utils/internal/devUtils'\n\nexport interface PrintStartMessageArgs {\n  quiet?: boolean\n  message?: string\n  workerUrl?: string\n  workerScope?: string\n}\n\n/**\n * Prints a worker activation message in the browser's console.\n */\nexport function printStartMessage(args: PrintStartMessageArgs = {}) {\n  if (args.quiet) {\n    return\n  }\n\n  const message = args.message || 'Mocking enabled.'\n\n  console.groupCollapsed(\n    `%c${devUtils.formatMessage(message)}`,\n    'color:orangered;font-weight:bold;',\n  )\n  console.log(\n    '%cDocumentation: %chttps://mswjs.io/docs',\n    'font-weight:bold',\n    'font-weight:normal',\n  )\n  console.log('Found an issue? https://github.com/mswjs/msw/issues')\n\n  if (args.workerUrl) {\n    console.log('Worker script URL:', args.workerUrl)\n  }\n\n  if (args.workerScope) {\n    console.log('Worker scope:', args.workerScope)\n  }\n\n  console.groupEnd()\n}\n", "import {\n  StringifiedResponse,\n  ServiceWorkerIncomingEventsMap,\n} from '../../glossary'\n\nexport interface ServiceWorkerMessage<\n  EventType extends keyof ServiceWorkerIncomingEventsMap,\n  EventPayload,\n> {\n  type: EventType\n  payload: EventPayload\n}\n\ninterface WorkerChannelEventsMap {\n  MOCK_RESPONSE: [\n    data: StringifiedResponse,\n    transfer?: [ReadableStream<Uint8Array>],\n  ]\n  PASSTHROUGH: []\n}\n\nexport class WorkerChannel {\n  constructor(private readonly port: MessagePort) {}\n\n  public postMessage<Event extends keyof WorkerChannelEventsMap>(\n    event: Event,\n    ...rest: WorkerChannelEventsMap[Event]\n  ): void {\n    const [data, transfer] = rest\n    this.port.postMessage({ type: event, data }, { transfer })\n  }\n}\n", "import type { ServiceWorkerIncomingRequest } from '../setupWorker/glossary'\n\ntype Input = Pick<ServiceWorkerIncomingRequest, 'method' | 'body'>\n\n/**\n * Ensures that an empty GET request body is always represented as `undefined`.\n */\nexport function pruneGetRequestBody(\n  request: Input,\n): ServiceWorkerIncomingRequest['body'] {\n  // Force HEAD/GET request body to always be empty.\n  // The worker reads any request's body as ArrayBuffer,\n  // and you cannot re-construct a GET/HEAD Request\n  // with an ArrayBuffer, even if empty. Also note that\n  // \"request.body\" is always undefined in the worker.\n  if (['HEAD', 'GET'].includes(request.method)) {\n    return undefined\n  }\n\n  return request.body\n}\n", "import { pruneGetRequestBody } from './pruneGetRequestBody'\nimport type { ServiceWorkerIncomingRequest } from '../setupWorker/glossary'\n\n/**\n * Converts a given request received from the Service Worker\n * into a Fetch `Request` instance.\n */\nexport function parseWorkerRequest(\n  incomingRequest: ServiceWorkerIncomingRequest,\n): Request {\n  return new Request(incomingRequest.url, {\n    ...incomingRequest,\n    body: pruneGetRequestBody(incomingRequest),\n  })\n}\n", "import {\n  StartOptions,\n  SetupWorkerInternalContext,\n  ServiceWorkerIncomingEventsMap,\n} from '../glossary'\nimport {\n  ServiceWorkerMessage,\n  WorkerChannel,\n} from './utils/createMessageChannel'\nimport { parseWorkerRequest } from '../../utils/parseWorkerRequest'\nimport { RequestHandler } from '~/core/handlers/RequestHandler'\nimport { handleRequest } from '~/core/utils/handleRequest'\nimport { RequiredDeep } from '~/core/typeUtils'\nimport { devUtils } from '~/core/utils/internal/devUtils'\nimport { toResponseInit } from '~/core/utils/toResponseInit'\n\nexport const createRequestListener = (\n  context: SetupWorkerInternalContext,\n  options: RequiredDeep<StartOptions>,\n) => {\n  return async (\n    event: MessageEvent,\n    message: ServiceWorkerMessage<\n      'REQUEST',\n      ServiceWorkerIncomingEventsMap['REQUEST']\n    >,\n  ) => {\n    const messageChannel = new WorkerChannel(event.ports[0])\n\n    const requestId = message.payload.id\n    const request = parseWorkerRequest(message.payload)\n    const requestCloneForLogs = request.clone()\n\n    // Make this the first requets clone before the\n    // request resolution pipeline even starts.\n    // Store the clone in cache so the first matching\n    // request handler would skip the cloning phase.\n    const requestClone = request.clone()\n    RequestHandler.cache.set(request, requestClone)\n    context.requests.set(requestId, requestClone)\n\n    try {\n      await handleRequest(\n        request,\n        requestId,\n        context.getRequestHandlers(),\n        options,\n        context.emitter,\n        {\n          onPassthroughResponse() {\n            messageChannel.postMessage('PASSTHROUGH')\n          },\n          async onMockedResponse(response, { handler, parsedResult }) {\n            // Clone the mocked response so its body could be read\n            // to buffer to be sent to the worker and also in the\n            // \".log()\" method of the request handler.\n            const responseClone = response.clone()\n            const responseCloneForLogs = response.clone()\n            const responseInit = toResponseInit(response)\n\n            /**\n             * @note Safari doesn't support transferring a \"ReadableStream\".\n             * Check that the browser supports that before sending it to the worker.\n             */\n            if (context.supports.readableStreamTransfer) {\n              const responseStreamOrNull = response.body\n\n              messageChannel.postMessage(\n                'MOCK_RESPONSE',\n                {\n                  ...responseInit,\n                  body: responseStreamOrNull,\n                },\n                responseStreamOrNull ? [responseStreamOrNull] : undefined,\n              )\n            } else {\n              /**\n               * @note If we are here, this means the current environment doesn't\n               * support \"ReadableStream\" as transferable. In that case,\n               * attempt to read the non-empty response body as ArrayBuffer, if it's not empty.\n               * @see https://github.com/mswjs/msw/issues/1827\n               */\n              const responseBufferOrNull =\n                response.body === null\n                  ? null\n                  : await responseClone.arrayBuffer()\n\n              messageChannel.postMessage('MOCK_RESPONSE', {\n                ...responseInit,\n                body: responseBufferOrNull,\n              })\n            }\n\n            if (!options.quiet) {\n              context.emitter.once('response:mocked', () => {\n                handler.log({\n                  request: requestCloneForLogs,\n                  response: responseCloneForLogs,\n                  parsedResult,\n                })\n              })\n            }\n          },\n        },\n      )\n    } catch (error) {\n      if (error instanceof Error) {\n        devUtils.error(\n          `Uncaught exception in the request handler for \"%s %s\":\n\n%s\n\nThis exception has been gracefully handled as a 500 response, however, it's strongly recommended to resolve this error, as it indicates a mistake in your code. If you wish to mock an error response, please see this guide: https://mswjs.io/docs/recipes/mocking-error-responses`,\n          request.method,\n          request.url,\n          error.stack ?? error,\n        )\n\n        // Treat all other exceptions in a request handler as unintended,\n        // alerting that there is a problem that needs fixing.\n        messageChannel.postMessage('MOCK_RESPONSE', {\n          status: 500,\n          statusText: 'Request Handler Error',\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          body: JSON.stringify({\n            name: error.name,\n            message: error.message,\n            stack: error.stack,\n          }),\n        })\n      }\n    }\n  }\n}\n", "import { devUtils } from '~/core/utils/internal/devUtils'\nimport type { SetupWorkerInternalContext } from '../setupWorker/glossary'\n\n/**\n * Check whether the registered Service Worker has been\n * generated by the installed version of the library.\n * Prints a warning message if the worker scripts mismatch.\n */\nexport async function checkWorkerIntegrity(\n  context: SetupWorkerInternalContext,\n): Promise<void> {\n  // Request the integrity checksum from the registered worker.\n  context.workerChannel.send('INTEGRITY_CHECK_REQUEST')\n\n  const { payload } = await context.events.once('INTEGRITY_CHECK_RESPONSE')\n\n  // Compare the response from the Service Worker and the\n  // global variable set during the build.\n\n  // The integrity is validated based on the worker script's checksum\n  // that's derived from its minified content during the build.\n  // The \"SERVICE_WORKER_CHECKSUM\" global variable is injected by the build.\n  if (payload.checksum !== SERVICE_WORKER_CHECKSUM) {\n    devUtils.warn(\n      `The currently registered Service Worker has been generated by a different version of MSW (${payload.packageVersion}) and may not be fully compatible with the installed version.\n\nIt's recommended you update your worker script by running this command:\n\n  \\u2022 npx msw init <PUBLIC_DIR>\n\nYou can also automate this process and make the worker script update automatically upon the library installations. Read more: https://mswjs.io/docs/cli/init.`,\n    )\n  }\n}\n", "const encoder = new TextEncoder()\n\nexport function encodeBuffer(text: string): Uint8Array {\n  return encoder.encode(text)\n}\n\nexport function decodeBuffer(buffer: ArrayBuffer, encoding?: string): string {\n  const decoder = new TextDecoder(encoding)\n  return decoder.decode(buffer)\n}\n\n/**\n * Create an `ArrayBuffer` from the given `Uint8Array`.\n * Takes the byte offset into account to produce the right buffer\n * in the case when the buffer is bigger than the data view.\n */\nexport function toArrayBuffer(array: Uint8Array): ArrayBuffer {\n  return array.buffer.slice(\n    array.byteOffset,\n    array.byteOffset + array.byteLength\n  )\n}\n", "/**\n * Response status codes for responses that cannot have body.\n * @see https://fetch.spec.whatwg.org/#statuses\n */\nexport const RESPONSE_STATUS_CODES_WITHOUT_BODY = new Set([\n  101, 103, 204, 205, 304,\n])\n\n/**\n * Returns a boolean indicating whether the given response status\n * code represents a response that cannot have a body.\n */\nexport function isResponseWithoutBody(status: number): boolean {\n  return RESPONSE_STATUS_CODES_WITHOUT_BODY.has(status)\n}\n", "import type { InteractiveRequest } from './utils/toInteractiveRequest'\n\nexport const IS_PATCHED_MODULE: unique symbol = Symbol('isPatchedModule')\n\nexport type RequestCredentials = 'omit' | 'include' | 'same-origin'\n\nexport type HttpRequestEventMap = {\n  request: [\n    args: {\n      request: InteractiveRequest\n      requestId: string\n    }\n  ]\n  response: [\n    args: {\n      response: Response\n      isMockedResponse: boolean\n      request: Request\n      requestId: string\n    }\n  ]\n}\n", "var __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/index.ts\nimport { isNodeProcess } from \"is-node-process\";\nimport { format } from \"outvariant\";\n\n// src/colors.ts\nvar colors_exports = {};\n__export(colors_exports, {\n  blue: () => blue,\n  gray: () => gray,\n  green: () => green,\n  red: () => red,\n  yellow: () => yellow\n});\nfunction yellow(text) {\n  return `\\x1B[33m${text}\\x1B[0m`;\n}\nfunction blue(text) {\n  return `\\x1B[34m${text}\\x1B[0m`;\n}\nfunction gray(text) {\n  return `\\x1B[90m${text}\\x1B[0m`;\n}\nfunction red(text) {\n  return `\\x1B[31m${text}\\x1B[0m`;\n}\nfunction green(text) {\n  return `\\x1B[32m${text}\\x1B[0m`;\n}\n\n// src/index.ts\nvar IS_NODE = isNodeProcess();\nvar Logger = class {\n  constructor(name) {\n    this.name = name;\n    this.prefix = `[${this.name}]`;\n    const LOGGER_NAME = getVariable(\"DEBUG\");\n    const LOGGER_LEVEL = getVariable(\"LOG_LEVEL\");\n    const isLoggingEnabled = LOGGER_NAME === \"1\" || LOGGER_NAME === \"true\" || typeof LOGGER_NAME !== \"undefined\" && this.name.startsWith(LOGGER_NAME);\n    if (isLoggingEnabled) {\n      this.debug = isDefinedAndNotEquals(LOGGER_LEVEL, \"debug\") ? noop : this.debug;\n      this.info = isDefinedAndNotEquals(LOGGER_LEVEL, \"info\") ? noop : this.info;\n      this.success = isDefinedAndNotEquals(LOGGER_LEVEL, \"success\") ? noop : this.success;\n      this.warning = isDefinedAndNotEquals(LOGGER_LEVEL, \"warning\") ? noop : this.warning;\n      this.error = isDefinedAndNotEquals(LOGGER_LEVEL, \"error\") ? noop : this.error;\n    } else {\n      this.info = noop;\n      this.success = noop;\n      this.warning = noop;\n      this.error = noop;\n      this.only = noop;\n    }\n  }\n  prefix;\n  extend(domain) {\n    return new Logger(`${this.name}:${domain}`);\n  }\n  /**\n   * Print a debug message.\n   * @example\n   * logger.debug('no duplicates found, creating a document...')\n   */\n  debug(message, ...positionals) {\n    this.logEntry({\n      level: \"debug\",\n      message: gray(message),\n      positionals,\n      prefix: this.prefix,\n      colors: {\n        prefix: \"gray\"\n      }\n    });\n  }\n  /**\n   * Print an info message.\n   * @example\n   * logger.info('start parsing...')\n   */\n  info(message, ...positionals) {\n    this.logEntry({\n      level: \"info\",\n      message,\n      positionals,\n      prefix: this.prefix,\n      colors: {\n        prefix: \"blue\"\n      }\n    });\n    const performance2 = new PerformanceEntry();\n    return (message2, ...positionals2) => {\n      performance2.measure();\n      this.logEntry({\n        level: \"info\",\n        message: `${message2} ${gray(`${performance2.deltaTime}ms`)}`,\n        positionals: positionals2,\n        prefix: this.prefix,\n        colors: {\n          prefix: \"blue\"\n        }\n      });\n    };\n  }\n  /**\n   * Print a success message.\n   * @example\n   * logger.success('successfully created document')\n   */\n  success(message, ...positionals) {\n    this.logEntry({\n      level: \"info\",\n      message,\n      positionals,\n      prefix: `\\u2714 ${this.prefix}`,\n      colors: {\n        timestamp: \"green\",\n        prefix: \"green\"\n      }\n    });\n  }\n  /**\n   * Print a warning.\n   * @example\n   * logger.warning('found legacy document format')\n   */\n  warning(message, ...positionals) {\n    this.logEntry({\n      level: \"warning\",\n      message,\n      positionals,\n      prefix: `\\u26A0 ${this.prefix}`,\n      colors: {\n        timestamp: \"yellow\",\n        prefix: \"yellow\"\n      }\n    });\n  }\n  /**\n   * Print an error message.\n   * @example\n   * logger.error('something went wrong')\n   */\n  error(message, ...positionals) {\n    this.logEntry({\n      level: \"error\",\n      message,\n      positionals,\n      prefix: `\\u2716 ${this.prefix}`,\n      colors: {\n        timestamp: \"red\",\n        prefix: \"red\"\n      }\n    });\n  }\n  /**\n   * Execute the given callback only when the logging is enabled.\n   * This is skipped in its entirety and has no runtime cost otherwise.\n   * This executes regardless of the log level.\n   * @example\n   * logger.only(() => {\n   *   logger.info('additional info')\n   * })\n   */\n  only(callback) {\n    callback();\n  }\n  createEntry(level, message) {\n    return {\n      timestamp: /* @__PURE__ */ new Date(),\n      level,\n      message\n    };\n  }\n  logEntry(args) {\n    const {\n      level,\n      message,\n      prefix,\n      colors: customColors,\n      positionals = []\n    } = args;\n    const entry = this.createEntry(level, message);\n    const timestampColor = customColors?.timestamp || \"gray\";\n    const prefixColor = customColors?.prefix || \"gray\";\n    const colorize = {\n      timestamp: colors_exports[timestampColor],\n      prefix: colors_exports[prefixColor]\n    };\n    const write = this.getWriter(level);\n    write(\n      [colorize.timestamp(this.formatTimestamp(entry.timestamp))].concat(prefix != null ? colorize.prefix(prefix) : []).concat(serializeInput(message)).join(\" \"),\n      ...positionals.map(serializeInput)\n    );\n  }\n  formatTimestamp(timestamp) {\n    return `${timestamp.toLocaleTimeString(\n      \"en-GB\"\n    )}:${timestamp.getMilliseconds()}`;\n  }\n  getWriter(level) {\n    switch (level) {\n      case \"debug\":\n      case \"success\":\n      case \"info\": {\n        return log;\n      }\n      case \"warning\": {\n        return warn;\n      }\n      case \"error\": {\n        return error;\n      }\n    }\n  }\n};\nvar PerformanceEntry = class {\n  startTime;\n  endTime;\n  deltaTime;\n  constructor() {\n    this.startTime = performance.now();\n  }\n  measure() {\n    this.endTime = performance.now();\n    const deltaTime = this.endTime - this.startTime;\n    this.deltaTime = deltaTime.toFixed(2);\n  }\n};\nvar noop = () => void 0;\nfunction log(message, ...positionals) {\n  if (IS_NODE) {\n    process.stdout.write(format(message, ...positionals) + \"\\n\");\n    return;\n  }\n  console.log(message, ...positionals);\n}\nfunction warn(message, ...positionals) {\n  if (IS_NODE) {\n    process.stderr.write(format(message, ...positionals) + \"\\n\");\n    return;\n  }\n  console.warn(message, ...positionals);\n}\nfunction error(message, ...positionals) {\n  if (IS_NODE) {\n    process.stderr.write(format(message, ...positionals) + \"\\n\");\n    return;\n  }\n  console.error(message, ...positionals);\n}\nfunction getVariable(variableName) {\n  if (IS_NODE) {\n    return process.env[variableName];\n  }\n  return globalThis[variableName]?.toString();\n}\nfunction isDefinedAndNotEquals(value, expected) {\n  return value !== void 0 && value !== expected;\n}\nfunction serializeInput(message) {\n  if (typeof message === \"undefined\") {\n    return \"undefined\";\n  }\n  if (message === null) {\n    return \"null\";\n  }\n  if (typeof message === \"string\") {\n    return message;\n  }\n  if (typeof message === \"object\") {\n    return JSON.stringify(message);\n  }\n  return message.toString();\n}\nexport {\n  Logger\n};\n", "import type { Emitter } from './Emitter'\n\nexport class MemoryLeakError extends Error {\n  constructor(\n    public readonly emitter: Emitter<any>,\n    public readonly type: string | number | symbol,\n    public readonly count: number\n  ) {\n    super(\n      `Possible EventEmitter memory leak detected. ${count} ${type.toString()} listeners added. Use emitter.setMaxListeners() to increase limit`\n    )\n    this.name = 'MaxListenersExceededWarning'\n  }\n}\n", "import { MemoryLeakError } from './MemoryLeakError'\n\nexport type EventMap = {\n  [eventName: string]: Array<unknown>\n}\n\nexport type InternalEventNames = 'newListener' | 'removeListener'\n\nexport type InternalListener<Events extends EventMap> = Listener<\n  [eventName: keyof Events, listener: Listener<Array<unknown>>]\n>\n\nexport type Listener<Data extends Array<unknown>> = (...data: Data) => void\n\n/**\n * Node.js-compatible implementation of `EventEmitter`.\n *\n * @example\n * const emitter = new Emitter<{ hello: [string] }>()\n * emitter.on('hello', (name) => console.log(name))\n * emitter.emit('hello', 'John')\n */\nexport class Emitter<Events extends EventMap> {\n  private events: Map<keyof Events, Array<Listener<any>>>\n  private maxListeners: number\n  private hasWarnedAboutPotentialMemoryLeak: boolean\n\n  static defaultMaxListeners = 10\n\n  static listenerCount<Events extends EventMap>(\n    emitter: Emitter<EventMap>,\n    eventName: keyof Events\n  ): number {\n    return emitter.listenerCount<any>(eventName)\n  }\n\n  constructor() {\n    this.events = new Map()\n    this.maxListeners = Emitter.defaultMaxListeners\n    this.hasWarnedAboutPotentialMemoryLeak = false\n  }\n\n  private _emitInternalEvent(\n    internalEventName: InternalEventNames,\n    eventName: keyof Events,\n    listener: Listener<Array<unknown>>\n  ): void {\n    this.emit(\n      internalEventName,\n      // Anything to make TypeScript happy.\n      ...([eventName, listener] as Events['newListener'] &\n        Events['removeListener'])\n    )\n  }\n\n  private _getListeners<EventName extends keyof Events>(\n    eventName: EventName\n  ): Array<Listener<Array<unknown>>> {\n    // Always return a copy of the listeners array\n    // so they are fixed at the time of the \"_getListeners\" call.\n    return Array.prototype.concat.apply([], this.events.get(eventName)) || []\n  }\n\n  private _removeListener<EventName extends keyof Events>(\n    listeners: Array<Listener<Events[EventName]>>,\n    listener: Listener<Events[EventName]>\n  ): Array<Listener<Events[EventName]>> {\n    const index = listeners.indexOf(listener)\n\n    if (index > -1) {\n      listeners.splice(index, 1)\n    }\n\n    return []\n  }\n\n  private _wrapOnceListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): Listener<Events[EventName]> {\n    const onceListener = (...data: Events[keyof Events]) => {\n      this.removeListener(eventName, onceListener)\n\n      /**\n       * @note Return the result of the original listener.\n       * This way this wrapped preserves listeners that are async.\n       */\n      return listener.apply(this, data)\n    }\n\n    // Inherit the name of the original listener.\n    Object.defineProperty(onceListener, 'name', { value: listener.name })\n\n    return onceListener\n  }\n\n  public setMaxListeners(maxListeners: number): this {\n    this.maxListeners = maxListeners\n    return this\n  }\n\n  /**\n   * Returns the current max listener value for the `Emitter` which is\n   * either set by `emitter.setMaxListeners(n)` or defaults to\n   * `Emitter.defaultMaxListeners`.\n   */\n  public getMaxListeners(): number {\n    return this.maxListeners\n  }\n\n  /**\n   * Returns an array listing the events for which the emitter has registered listeners.\n   * The values in the array will be strings or Symbols.\n   */\n  public eventNames(): Array<keyof Events> {\n    return Array.from(this.events.keys())\n  }\n\n  /**\n   * Synchronously calls each of the listeners registered for the event named `eventName`,\n   * in the order they were registered, passing the supplied arguments to each.\n   * Returns `true` if the event has listeners, `false` otherwise.\n   *\n   * @example\n   * const emitter = new Emitter<{ hello: [string] }>()\n   * emitter.emit('hello', 'John')\n   */\n  public emit<EventName extends keyof Events>(\n    eventName: EventName,\n    ...data: Events[EventName]\n  ): boolean {\n    const listeners = this._getListeners(eventName)\n    listeners.forEach((listener) => {\n      listener.apply(this, data)\n    })\n\n    return listeners.length > 0\n  }\n\n  public addListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public addListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public addListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: InternalListener<Events> | Listener<Events[any]>\n  ): this {\n    // Emit the `newListener` event before adding the listener.\n    this._emitInternalEvent('newListener', eventName, listener)\n\n    const nextListeners = this._getListeners(eventName).concat(listener)\n    this.events.set(eventName, nextListeners)\n\n    if (\n      this.maxListeners > 0 &&\n      this.listenerCount(eventName) > this.maxListeners &&\n      !this.hasWarnedAboutPotentialMemoryLeak\n    ) {\n      this.hasWarnedAboutPotentialMemoryLeak = true\n\n      const memoryLeakWarning = new MemoryLeakError(\n        this,\n        eventName,\n        this.listenerCount(eventName)\n      )\n      console.warn(memoryLeakWarning)\n    }\n\n    return this\n  }\n\n  public on(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public on<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public on<EventName extends keyof Events>(\n    eventName: 'removeListener' | EventName,\n    listener: Listener<any>\n  ): this {\n    return this.addListener(eventName, listener)\n  }\n\n  public once(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public once<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public once<EventName extends keyof Events>(\n    eventName: InternalEventNames | EventName,\n    listener: Listener<any>\n  ): this {\n    return this.addListener(\n      eventName,\n      this._wrapOnceListener(eventName, listener)\n    )\n  }\n\n  public prependListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public prependListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public prependListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    const listeners = this._getListeners(eventName)\n\n    if (listeners.length > 0) {\n      const nextListeners = [listener].concat(listeners)\n      this.events.set(eventName, nextListeners)\n    } else {\n      this.events.set(eventName, listeners.concat(listener))\n    }\n\n    return this\n  }\n\n  public prependOnceListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public prependOnceListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public prependOnceListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    return this.prependListener(\n      eventName,\n      this._wrapOnceListener(eventName, listener)\n    )\n  }\n\n  public removeListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public removeListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public removeListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    const listeners = this._getListeners(eventName)\n\n    if (listeners.length > 0) {\n      this._removeListener(listeners, listener)\n      this.events.set(eventName, listeners)\n\n      // Emit the `removeListener` event after removing the listener.\n      this._emitInternalEvent('removeListener', eventName, listener)\n    }\n\n    return this\n  }\n\n  public off(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public off<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  /**\n   * Alias for `emitter.removeListener()`.\n   *\n   * @example\n   * emitter.off('hello', listener)\n   */\n  public off(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    return this.removeListener(eventName, listener)\n  }\n\n  public removeAllListeners(eventName?: InternalEventNames): this\n  public removeAllListeners<EventName extends keyof Events>(\n    eventName?: EventName\n  ): this\n  public removeAllListeners(\n    eventName?: InternalEventNames | keyof Events\n  ): this {\n    if (eventName) {\n      this.events.delete(eventName)\n    } else {\n      this.events.clear()\n    }\n\n    return this\n  }\n\n  public listeners(eventName: InternalEventNames): Array<Listener<any>>\n  public listeners<EventName extends keyof Events>(\n    eventName: EventName\n  ): Array<Listener<Events[EventName]>>\n  /**\n   * Returns a copy of the array of listeners for the event named `eventName`.\n   */\n  public listeners(eventName: InternalEventNames | keyof Events) {\n    return Array.from(this._getListeners(eventName))\n  }\n\n  public listenerCount(eventName: InternalEventNames): number\n  public listenerCount<EventName extends keyof Events>(\n    eventName: EventName\n  ): number\n  /**\n   * Returns the number of listeners listening to the event named `eventName`.\n   */\n  public listenerCount(eventName: InternalEventNames | keyof Events): number {\n    return this._getListeners(eventName).length\n  }\n\n  public rawListeners<EventName extends keyof Events>(\n    eventName: EventName\n  ): Array<Listener<Events[EventName]>> {\n    return this.listeners(eventName)\n  }\n}\n", "import { Logger } from '@open-draft/logger'\nimport { Emitter, Listener } from 'strict-event-emitter'\n\nexport type InterceptorEventMap = Record<string, any>\nexport type InterceptorSubscription = () => void\n\n/**\n * Request header name to detect when a single request\n * is being handled by nested interceptors (XHR -> ClientRequest).\n * Obscure by design to prevent collisions with user-defined headers.\n * Ideally, come up with the Interceptor-level mechanism for this.\n * @see https://github.com/mswjs/interceptors/issues/378\n */\nexport const INTERNAL_REQUEST_ID_HEADER_NAME =\n  'x-interceptors-internal-request-id'\n\nexport function getGlobalSymbol<V>(symbol: Symbol): V | undefined {\n  return (\n    // @ts-ignore https://github.com/Microsoft/TypeScript/issues/24587\n    globalThis[symbol] || undefined\n  )\n}\n\nfunction setGlobalSymbol(symbol: Symbol, value: any): void {\n  // @ts-ignore\n  globalThis[symbol] = value\n}\n\nexport function deleteGlobalSymbol(symbol: Symbol): void {\n  // @ts-ignore\n  delete globalThis[symbol]\n}\n\nexport enum InterceptorReadyState {\n  INACTIVE = 'INACTIVE',\n  APPLYING = 'APPLYING',\n  APPLIED = 'APPLIED',\n  DISPOSING = 'DISPOSING',\n  DISPOSED = 'DISPOSED',\n}\n\nexport type ExtractEventNames<Events extends Record<string, any>> =\n  Events extends Record<infer EventName, any> ? EventName : never\n\nexport class Interceptor<Events extends InterceptorEventMap> {\n  protected emitter: Emitter<Events>\n  protected subscriptions: Array<InterceptorSubscription>\n  protected logger: Logger\n\n  public readyState: InterceptorReadyState\n\n  constructor(private readonly symbol: symbol) {\n    this.readyState = InterceptorReadyState.INACTIVE\n\n    this.emitter = new Emitter()\n    this.subscriptions = []\n    this.logger = new Logger(symbol.description!)\n\n    // Do not limit the maximum number of listeners\n    // so not to limit the maximum amount of parallel events emitted.\n    this.emitter.setMaxListeners(0)\n\n    this.logger.info('constructing the interceptor...')\n  }\n\n  /**\n   * Determine if this interceptor can be applied\n   * in the current environment.\n   */\n  protected checkEnvironment(): boolean {\n    return true\n  }\n\n  /**\n   * Apply this interceptor to the current process.\n   * Returns an already running interceptor instance if it's present.\n   */\n  public apply(): void {\n    const logger = this.logger.extend('apply')\n    logger.info('applying the interceptor...')\n\n    if (this.readyState === InterceptorReadyState.APPLIED) {\n      logger.info('intercepted already applied!')\n      return\n    }\n\n    const shouldApply = this.checkEnvironment()\n\n    if (!shouldApply) {\n      logger.info('the interceptor cannot be applied in this environment!')\n      return\n    }\n\n    this.readyState = InterceptorReadyState.APPLYING\n\n    // Whenever applying a new interceptor, check if it hasn't been applied already.\n    // This enables to apply the same interceptor multiple times, for example from a different\n    // interceptor, only proxying events but keeping the stubs in a single place.\n    const runningInstance = this.getInstance()\n\n    if (runningInstance) {\n      logger.info('found a running instance, reusing...')\n\n      // Proxy any listeners you set on this instance to the running instance.\n      this.on = (event, listener) => {\n        logger.info('proxying the \"%s\" listener', event)\n\n        // Add listeners to the running instance so they appear\n        // at the top of the event listeners list and are executed first.\n        runningInstance.emitter.addListener(event, listener)\n\n        // Ensure that once this interceptor instance is disposed,\n        // it removes all listeners it has appended to the running interceptor instance.\n        this.subscriptions.push(() => {\n          runningInstance.emitter.removeListener(event, listener)\n          logger.info('removed proxied \"%s\" listener!', event)\n        })\n\n        return this\n      }\n\n      this.readyState = InterceptorReadyState.APPLIED\n\n      return\n    }\n\n    logger.info('no running instance found, setting up a new instance...')\n\n    // Setup the interceptor.\n    this.setup()\n\n    // Store the newly applied interceptor instance globally.\n    this.setInstance()\n\n    this.readyState = InterceptorReadyState.APPLIED\n  }\n\n  /**\n   * Setup the module augments and stubs necessary for this interceptor.\n   * This method is not run if there's a running interceptor instance\n   * to prevent instantiating an interceptor multiple times.\n   */\n  protected setup(): void {}\n\n  /**\n   * Listen to the interceptor's public events.\n   */\n  public on<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    const logger = this.logger.extend('on')\n\n    if (\n      this.readyState === InterceptorReadyState.DISPOSING ||\n      this.readyState === InterceptorReadyState.DISPOSED\n    ) {\n      logger.info('cannot listen to events, already disposed!')\n      return this\n    }\n\n    logger.info('adding \"%s\" event listener:', event, listener)\n\n    this.emitter.on(event, listener)\n    return this\n  }\n\n  public once<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    this.emitter.once(event, listener)\n    return this\n  }\n\n  public off<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    this.emitter.off(event, listener)\n    return this\n  }\n\n  public removeAllListeners<EventName extends ExtractEventNames<Events>>(\n    event?: EventName\n  ): this {\n    this.emitter.removeAllListeners(event)\n    return this\n  }\n\n  /**\n   * Disposes of any side-effects this interceptor has introduced.\n   */\n  public dispose(): void {\n    const logger = this.logger.extend('dispose')\n\n    if (this.readyState === InterceptorReadyState.DISPOSED) {\n      logger.info('cannot dispose, already disposed!')\n      return\n    }\n\n    logger.info('disposing the interceptor...')\n    this.readyState = InterceptorReadyState.DISPOSING\n\n    if (!this.getInstance()) {\n      logger.info('no interceptors running, skipping dispose...')\n      return\n    }\n\n    // Delete the global symbol as soon as possible,\n    // indicating that the interceptor is no longer running.\n    this.clearInstance()\n\n    logger.info('global symbol deleted:', getGlobalSymbol(this.symbol))\n\n    if (this.subscriptions.length > 0) {\n      logger.info('disposing of %d subscriptions...', this.subscriptions.length)\n\n      for (const dispose of this.subscriptions) {\n        dispose()\n      }\n\n      this.subscriptions = []\n\n      logger.info('disposed of all subscriptions!', this.subscriptions.length)\n    }\n\n    this.emitter.removeAllListeners()\n    logger.info('destroyed the listener!')\n\n    this.readyState = InterceptorReadyState.DISPOSED\n  }\n\n  private getInstance(): this | undefined {\n    const instance = getGlobalSymbol<this>(this.symbol)\n    this.logger.info('retrieved global instance:', instance?.constructor?.name)\n    return instance\n  }\n\n  private setInstance(): void {\n    setGlobalSymbol(this.symbol, this)\n    this.logger.info('set global instance!', this.symbol.description)\n  }\n\n  private clearInstance(): void {\n    deleteGlobalSymbol(this.symbol)\n    this.logger.info('cleared global instance!', this.symbol.description)\n  }\n}\n", "/**\n * Generate a random ID string to represent a request.\n * @example\n * createRequestId()\n * // \"f774b6c9c600f\"\n */\nexport function createRequestId(): string {\n  return Math.random().toString(16).slice(2)\n}\n", "import { EventMap, Listener } from 'strict-event-emitter'\nimport { Interceptor, ExtractEventNames } from './Interceptor'\n\nexport interface BatchInterceptorOptions<\n  InterceptorList extends ReadonlyArray<Interceptor<any>>\n> {\n  name: string\n  interceptors: InterceptorList\n}\n\nexport type ExtractEventMapType<\n  InterceptorList extends ReadonlyArray<Interceptor<any>>\n> = InterceptorList extends ReadonlyArray<infer InterceptorType>\n  ? InterceptorType extends Interceptor<infer EventMap>\n    ? EventMap\n    : never\n  : never\n\n/**\n * A batch interceptor that exposes a single interface\n * to apply and operate with multiple interceptors at once.\n */\nexport class BatchInterceptor<\n  InterceptorList extends ReadonlyArray<Interceptor<any>>,\n  Events extends EventMap = ExtractEventMapType<InterceptorList>\n> extends Interceptor<Events> {\n  static symbol: symbol\n\n  private interceptors: InterceptorList\n\n  constructor(options: BatchInterceptorOptions<InterceptorList>) {\n    BatchInterceptor.symbol = Symbol(options.name)\n    super(BatchInterceptor.symbol)\n    this.interceptors = options.interceptors\n  }\n\n  protected setup() {\n    const logger = this.logger.extend('setup')\n\n    logger.info('applying all %d interceptors...', this.interceptors.length)\n\n    for (const interceptor of this.interceptors) {\n      logger.info('applying \"%s\" interceptor...', interceptor.constructor.name)\n      interceptor.apply()\n\n      logger.info('adding interceptor dispose subscription')\n      this.subscriptions.push(() => interceptor.dispose())\n    }\n  }\n\n  public on<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    // Instead of adding a listener to the batch interceptor,\n    // propagate the listener to each of the individual interceptors.\n    for (const interceptor of this.interceptors) {\n      interceptor.on(event, listener)\n    }\n\n    return this\n  }\n\n  public once<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    for (const interceptor of this.interceptors) {\n      interceptor.once(event, listener)\n    }\n\n    return this\n  }\n\n  public off<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    for (const interceptor of this.interceptors) {\n      interceptor.off(event, listener)\n    }\n\n    return this\n  }\n\n  public removeAllListeners<EventName extends ExtractEventNames<Events>>(\n    event?: EventName | undefined\n  ): this {\n    for (const interceptors of this.interceptors) {\n      interceptors.removeAllListeners(event)\n    }\n\n    return this\n  }\n}\n", "/**\n * Removes query parameters and hashes from a given URL.\n */\nexport function getCleanUrl(url: URL, isAbsolute: boolean = true): string {\n  return [isAbsolute && url.origin, url.pathname].filter(Boolean).join('')\n}\n", "import type {\n  ServiceWorkerIncomingEventsMap,\n  SetupWorkerInternalContext,\n} from '../glossary'\nimport type { ServiceWorkerMessage } from './utils/createMessageChannel'\nimport { isResponseWithoutBody } from '@mswjs/interceptors'\n\nexport function createResponseListener(context: SetupWorkerInternalContext) {\n  return (\n    _: MessageEvent,\n    message: ServiceWorkerMessage<\n      'RESPONSE',\n      ServiceWorkerIncomingEventsMap['RESPONSE']\n    >,\n  ) => {\n    const { payload: responseJson } = message\n\n    // Get the Request instance reference stored in the\n    // request listener.\n    const { requestId } = responseJson\n    const request = context.requests.get(requestId)!\n    context.requests.delete(requestId)\n\n    /**\n     * CORS requests with `mode: \"no-cors\"` result in \"opaque\" responses.\n     * That kind of responses cannot be manipulated in JavaScript due\n     * to the security considerations.\n     * @see https://fetch.spec.whatwg.org/#concept-filtered-response-opaque\n     * @see https://github.com/mswjs/msw/issues/529\n     */\n    if (responseJson.type?.includes('opaque')) {\n      return\n    }\n\n    const response =\n      responseJson.status === 0\n        ? Response.error()\n        : new Response(\n            /**\n             * Responses may be streams here, but when we create a response object\n             * with null-body status codes, like 204, 205, 304 Response will\n             * throw when passed a non-null body, so ensure it's null here\n             * for those codes\n             */\n            isResponseWithoutBody(responseJson.status)\n              ? null\n              : responseJson.body,\n            responseJson,\n          )\n\n    /**\n     * Set response URL if it's not set already.\n     * @see https://github.com/mswjs/msw/issues/2030\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Response/url\n     */\n    if (!response.url) {\n      Object.defineProperty(response, 'url', {\n        value: request.url,\n        enumerable: true,\n        writable: false,\n      })\n    }\n\n    context.emitter.emit(\n      responseJson.isMockedResponse ? 'response:mocked' : 'response:bypass',\n      {\n        response,\n        request,\n        requestId: responseJson.requestId,\n      },\n    )\n  }\n}\n", "import { devUtils } from '~/core/utils/internal/devUtils'\nimport { StartOptions } from '../../glossary'\n\nexport function validateWorkerScope(\n  registration: ServiceWorkerRegistration,\n  options?: StartOptions,\n): void {\n  if (!options?.quiet && !location.href.startsWith(registration.scope)) {\n    devUtils.warn(\n      `\\\nCannot intercept requests on this page because it's outside of the worker's scope (\"${registration.scope}\"). If you wish to mock API requests on this page, you must resolve this scope issue.\n\n- (Recommended) Register the worker at the root level (\"/\") of your application.\n- Set the \"Service-Worker-Allowed\" response header to allow out-of-scope workers.\\\n`,\n    )\n  }\n}\n", "import { devUtils } from '~/core/utils/internal/devUtils'\nimport { SetupWorkerInternalContext, StopHandler } from '../glossary'\nimport { printStopMessage } from './utils/printStopMessage'\n\nexport const createStop = (\n  context: SetupWorkerInternalContext,\n): StopHandler => {\n  return function stop() {\n    // Warn developers calling \"worker.stop()\" more times than necessary.\n    // This likely indicates a mistake in their code.\n    if (!context.isMockingEnabled) {\n      devUtils.warn(\n        'Found a redundant \"worker.stop()\" call. Note that stopping the worker while mocking already stopped has no effect. Consider removing this \"worker.stop()\" call.',\n      )\n      return\n    }\n\n    /**\n     * Signal the Service Worker to disable mocking for this client.\n     * Use this an an explicit way to stop the mocking, while preserving\n     * the worker-client relation. Does not affect the worker's lifecycle.\n     */\n    context.workerChannel.send('MOCK_DEACTIVATE')\n    context.isMockingEnabled = false\n    window.clearInterval(context.keepAliveInterval)\n\n    printStopMessage({ quiet: context.startOptions?.quiet })\n  }\n}\n", "import { devUtils } from '~/core/utils/internal/devUtils'\n\nexport function printStopMessage(args: { quiet?: boolean } = {}): void {\n  if (args.quiet) {\n    return\n  }\n\n  console.log(\n    `%c${devUtils.formatMessage('Mocking disabled.')}`,\n    'color:orangered;font-weight:bold;',\n  )\n}\n", "import { RequiredDeep } from '~/core/typeUtils'\nimport { mergeRight } from '~/core/utils/internal/mergeRight'\nimport {\n  SetupWorker,\n  SetupWorkerInternalContext,\n  StartHandler,\n  StartOptions,\n} from '../../glossary'\n\nexport const DEFAULT_START_OPTIONS: RequiredDeep<StartOptions> = {\n  serviceWorker: {\n    url: '/mockServiceWorker.js',\n    options: null as any,\n  },\n  quiet: false,\n  waitUntilReady: true,\n  onUnhandledRequest: 'warn',\n  findWorker(scriptURL, mockServiceWorkerUrl) {\n    return scriptURL === mockServiceWorkerUrl\n  },\n}\n\n/**\n * Returns resolved worker start options, merging the default options\n * with the given custom options.\n */\nexport function resolveStartOptions(\n  initialOptions?: StartOptions,\n): RequiredDeep<StartOptions> {\n  return mergeRight(\n    DEFAULT_START_OPTIONS,\n    initialOptions || {},\n  ) as RequiredDeep<StartOptions>\n}\n\nexport function prepareStartHandler(\n  handler: StartHandler,\n  context: SetupWorkerInternalContext,\n): SetupWorker['start'] {\n  return (initialOptions) => {\n    context.startOptions = resolveStartOptions(initialOptions)\n    return handler(context.startOptions, initialOptions || {})\n  }\n}\n", "export type PromiseState = 'pending' | 'fulfilled' | 'rejected'\n\nexport type Executor<Value> = ConstructorParameters<typeof Promise<Value>>[0]\nexport type ResolveFunction<Value> = Parameters<Executor<Value>>[0]\nexport type RejectFunction<Reason> = Parameters<Executor<Reason>>[1]\n\nexport type DeferredPromiseExecutor<Input = never, Output = Input> = {\n  (resolve?: ResolveFunction<Input>, reject?: RejectFunction<any>): void\n\n  resolve: ResolveFunction<Input>\n  reject: RejectFunction<any>\n  result?: Output\n  state: PromiseState\n  rejectionReason?: unknown\n}\nexport function createDeferredExecutor<\n  Input = never,\n  Output = Input\n>(): DeferredPromiseExecutor<Input, Output> {\n  const executor = <DeferredPromiseExecutor<Input, Output>>((\n    resolve,\n    reject\n  ) => {\n    executor.state = 'pending'\n\n    executor.resolve = (data) => {\n      if (executor.state !== 'pending') {\n        return\n      }\n\n      executor.result = data as Output\n\n      const onFulfilled = <Value>(value: Value) => {\n        executor.state = 'fulfilled'\n        return value\n      }\n\n      return resolve(\n        data instanceof Promise ? data : Promise.resolve(data).then(onFulfilled)\n      )\n    }\n\n    executor.reject = (reason) => {\n      if (executor.state !== 'pending') {\n        return\n      }\n\n      queueMicrotask(() => {\n        executor.state = 'rejected'\n      })\n\n      return reject((executor.rejectionReason = reason))\n    }\n  })\n\n  return executor\n}\n", "import {\n  type Executor,\n  type RejectFunction,\n  type ResolveFunction,\n  type DeferredPromiseExecutor,\n  createDeferredExecutor,\n} from './createDeferredExecutor'\n\nexport class DeferredPromise<Input, Output = Input> extends Promise<Input> {\n  #executor: DeferredPromiseExecutor\n\n  public resolve: ResolveFunction<Output>\n  public reject: RejectFunction<Output>\n\n  constructor(executor: Executor<Input> | null = null) {\n    const deferredExecutor = createDeferredExecutor()\n    super((originalResolve, originalReject) => {\n      deferredExecutor(originalResolve, originalReject)\n      executor?.(deferredExecutor.resolve, deferredExecutor.reject)\n    })\n\n    this.#executor = deferredExecutor\n    this.resolve = this.#executor.resolve\n    this.reject = this.#executor.reject\n  }\n\n  public get state() {\n    return this.#executor.state\n  }\n\n  public get rejectionReason() {\n    return this.#executor.rejectionReason\n  }\n\n  public then<ThenResult = Input, CatchResult = never>(\n    onFulfilled?: (value: Input) => ThenResult | PromiseLike<ThenResult>,\n    onRejected?: (reason: any) => CatchResult | PromiseLike<CatchResult>\n  ) {\n    return this.#decorate(super.then(onFulfilled, onRejected))\n  }\n\n  public catch<CatchResult = never>(\n    onRejected?: (reason: any) => CatchResult | PromiseLike<CatchResult>\n  ) {\n    return this.#decorate(super.catch(onRejected))\n  }\n\n  public finally(onfinally?: () => void | Promise<any>) {\n    return this.#decorate(super.finally(onfinally))\n  }\n\n  #decorate<ChildInput>(\n    promise: Promise<ChildInput>\n  ): DeferredPromise<ChildInput, Output> {\n    return Object.defineProperties(promise, {\n      resolve: { configurable: true, value: this.resolve },\n      reject: { configurable: true, value: this.reject },\n    }) as DeferredPromise<ChildInput, Output>\n  }\n}\n", "import { invariant } from 'outvariant'\nimport { DeferredPromise } from '@open-draft/deferred-promise'\n\nexport class RequestController {\n  public responsePromise: DeferredPromise<Response | undefined>\n\n  constructor(protected request: Request) {\n    this.responsePromise = new DeferredPromise()\n  }\n\n  public respondWith(response?: Response): void {\n    invariant(\n      this.responsePromise.state === 'pending',\n      'Failed to respond to \"%s %s\" request: the \"request\" event has already been responded to.',\n      this.request.method,\n      this.request.url\n    )\n\n    this.responsePromise.resolve(response)\n  }\n}\n", "import { RequestController } from './RequestController'\n\nexport type InteractiveRequest = globalThis.Request & {\n  respondWith: RequestController['respondWith']\n}\n\nexport function toInteractiveRequest(request: Request): {\n  interactiveRequest: InteractiveRequest\n  requestController: RequestController\n} {\n  const requestController = new RequestController(request)\n\n  Reflect.set(\n    request,\n    'respondWith',\n    requestController.respondWith.bind(requestController)\n  )\n\n  return {\n    interactiveRequest: request as InteractiveRequest,\n    requestController,\n  }\n}\n", "import { Emitter, EventMap } from 'strict-event-emitter'\n\n/**\n * Emits an event on the given emitter but executes\n * the listeners sequentially. This accounts for asynchronous\n * listeners (e.g. those having \"sleep\" and handling the request).\n */\nexport async function emitAsync<\n  Events extends EventMap,\n  EventName extends keyof Events\n>(\n  emitter: Emitter<Events>,\n  eventName: EventName,\n  ...data: Events[EventName]\n): Promise<void> {\n  const listners = emitter.listeners(eventName)\n\n  if (listners.length === 0) {\n    return\n  }\n\n  for (const listener of listners) {\n    await listener.apply(emitter, data)\n  }\n}\n", "import { invariant } from 'outvariant'\nimport { DeferredPromise } from '@open-draft/deferred-promise'\nimport { until } from '@open-draft/until'\nimport { HttpRequestEventMap, IS_PATCHED_MODULE } from '../../glossary'\nimport { Interceptor } from '../../Interceptor'\nimport { toInteractiveRequest } from '../../utils/toInteractiveRequest'\nimport { emitAsync } from '../../utils/emitAsync'\nimport { isPropertyAccessible } from '../../utils/isPropertyAccessible'\nimport { canParseUrl } from '../../utils/canParseUrl'\nimport { createRequestId } from '../../createRequestId'\n\nexport class FetchInterceptor extends Interceptor<HttpRequestEventMap> {\n  static symbol = Symbol('fetch')\n\n  constructor() {\n    super(FetchInterceptor.symbol)\n  }\n\n  protected checkEnvironment() {\n    return (\n      typeof globalThis !== 'undefined' &&\n      typeof globalThis.fetch !== 'undefined'\n    )\n  }\n\n  protected async setup() {\n    const pureFetch = globalThis.fetch\n\n    invariant(\n      !(pureFetch as any)[IS_PATCHED_MODULE],\n      'Failed to patch the \"fetch\" module: already patched.'\n    )\n\n    globalThis.fetch = async (input, init) => {\n      const requestId = createRequestId()\n\n      /**\n       * @note Resolve potentially relative request URL\n       * against the present `location`. This is mainly\n       * for native `fetch` in JSDOM.\n       * @see https://github.com/mswjs/msw/issues/1625\n       */\n      const resolvedInput =\n        typeof input === 'string' &&\n        typeof location !== 'undefined' &&\n        !canParseUrl(input)\n          ? new URL(input, location.origin)\n          : input\n\n      const request = new Request(resolvedInput, init)\n\n      this.logger.info('[%s] %s', request.method, request.url)\n\n      const { interactiveRequest, requestController } =\n        toInteractiveRequest(request)\n\n      this.logger.info(\n        'emitting the \"request\" event for %d listener(s)...',\n        this.emitter.listenerCount('request')\n      )\n\n      this.emitter.once('request', ({ requestId: pendingRequestId }) => {\n        if (pendingRequestId !== requestId) {\n          return\n        }\n\n        if (requestController.responsePromise.state === 'pending') {\n          requestController.responsePromise.resolve(undefined)\n        }\n      })\n\n      this.logger.info('awaiting for the mocked response...')\n\n      const signal = interactiveRequest.signal\n      const requestAborted = new DeferredPromise()\n\n      // Signal isn't always defined in react-native.\n      if (signal) {\n        signal.addEventListener(\n          'abort',\n          () => {\n            requestAborted.reject(signal.reason)\n          },\n          { once: true }\n        )\n      }\n\n      const resolverResult = await until(async () => {\n        const listenersFinished = emitAsync(this.emitter, 'request', {\n          request: interactiveRequest,\n          requestId,\n        })\n\n        await Promise.race([\n          requestAborted,\n          // Put the listeners invocation Promise in the same race condition\n          // with the request abort Promise because otherwise awaiting the listeners\n          // would always yield some response (or undefined).\n          listenersFinished,\n          requestController.responsePromise,\n        ])\n\n        this.logger.info('all request listeners have been resolved!')\n\n        const mockedResponse = await requestController.responsePromise\n        this.logger.info('event.respondWith called with:', mockedResponse)\n\n        return mockedResponse\n      })\n\n      if (requestAborted.state === 'rejected') {\n        return Promise.reject(requestAborted.rejectionReason)\n      }\n\n      if (resolverResult.error) {\n        return Promise.reject(createNetworkError(resolverResult.error))\n      }\n\n      const mockedResponse = resolverResult.data\n\n      if (mockedResponse && !request.signal?.aborted) {\n        this.logger.info('received mocked response:', mockedResponse)\n\n        // Reject the request Promise on mocked \"Response.error\" responses.\n        if (\n          isPropertyAccessible(mockedResponse, 'type') &&\n          mockedResponse.type === 'error'\n        ) {\n          this.logger.info(\n            'received a network error response, rejecting the request promise...'\n          )\n\n          /**\n           * Set the cause of the request promise rejection to the\n           * network error Response instance. This different from Undici.\n           * Undici will forward the \"response.error\" custom property\n           * as the rejection reason but for \"Response.error()\" static method\n           * \"response.error\" will equal to undefined, making \"cause\" an empty Error.\n           * @see https://github.com/nodejs/undici/blob/83cb522ae0157a19d149d72c7d03d46e34510d0a/lib/fetch/response.js#L344\n           */\n          return Promise.reject(createNetworkError(mockedResponse))\n        }\n\n        // Clone the mocked response for the \"response\" event listener.\n        // This way, the listener can read the response and not lock its body\n        // for the actual fetch consumer.\n        const responseClone = mockedResponse.clone()\n\n        this.emitter.emit('response', {\n          response: responseClone,\n          isMockedResponse: true,\n          request: interactiveRequest,\n          requestId,\n        })\n\n        // Set the \"response.url\" property to equal the intercepted request URL.\n        Object.defineProperty(mockedResponse, 'url', {\n          writable: false,\n          enumerable: true,\n          configurable: false,\n          value: request.url,\n        })\n\n        return mockedResponse\n      }\n\n      this.logger.info('no mocked response received!')\n\n      return pureFetch(request).then((response) => {\n        const responseClone = response.clone()\n        this.logger.info('original fetch performed', responseClone)\n\n        this.emitter.emit('response', {\n          response: responseClone,\n          isMockedResponse: false,\n          request: interactiveRequest,\n          requestId,\n        })\n\n        return response\n      })\n    }\n\n    Object.defineProperty(globalThis.fetch, IS_PATCHED_MODULE, {\n      enumerable: true,\n      configurable: true,\n      value: true,\n    })\n\n    this.subscriptions.push(() => {\n      Object.defineProperty(globalThis.fetch, IS_PATCHED_MODULE, {\n        value: undefined,\n      })\n\n      globalThis.fetch = pureFetch\n\n      this.logger.info(\n        'restored native \"globalThis.fetch\"!',\n        globalThis.fetch.name\n      )\n    })\n  }\n}\n\nfunction createNetworkError(cause: unknown) {\n  return Object.assign(new TypeError('Failed to fetch'), {\n    cause,\n  })\n}\n", "/**\n * A function that validates if property access is possible on an object\n * without throwing. It returns `true` if the property access is possible\n * and `false` otherwise.\n *\n * Environments like miniflare will throw on property access on certain objects\n * like Request and Response, for unimplemented properties.\n */\nexport function isPropertyAccessible<Obj extends Record<string, any>>(\n  obj: Obj,\n  key: keyof Obj\n) {\n  try {\n    obj[key]\n    return true\n  } catch {\n    return false\n  }\n}\n", "/**\n * Returns a boolean indicating whether the given URL string\n * can be parsed into a `URL` instance.\n * A substitute for `URL.canParse()` for Node.js 18.\n */\nexport function canParseUrl(url: string): boolean {\n  try {\n    new URL(url)\n    return true\n  } catch (_error) {\n    return false\n  }\n}\n", "import { invariant } from 'outvariant'\nimport { Emitter } from 'strict-event-emitter'\nimport { HttpRequestEventMap, IS_PATCHED_MODULE } from '../../glossary'\nimport { InteractiveRequest } from '../../utils/toInteractiveRequest'\nimport { Interceptor } from '../../Interceptor'\nimport { createXMLHttpRequestProxy } from './XMLHttpRequestProxy'\n\nexport type XMLHttpRequestEventListener = (args: {\n  request: InteractiveRequest\n  requestId: string\n}) => Promise<void> | void\n\nexport type XMLHttpRequestEmitter = Emitter<HttpRequestEventMap>\n\nexport class XMLHttpRequestInterceptor extends Interceptor<HttpRequestEventMap> {\n  static interceptorSymbol = Symbol('xhr')\n\n  constructor() {\n    super(XMLHttpRequestInterceptor.interceptorSymbol)\n  }\n\n  protected checkEnvironment() {\n    return typeof globalThis.XMLHttpRequest !== 'undefined'\n  }\n\n  protected setup() {\n    const logger = this.logger.extend('setup')\n\n    logger.info('patching \"XMLHttpRequest\" module...')\n\n    const PureXMLHttpRequest = globalThis.XMLHttpRequest\n\n    invariant(\n      !(PureXMLHttpRequest as any)[IS_PATCHED_MODULE],\n      'Failed to patch the \"XMLHttpRequest\" module: already patched.'\n    )\n\n    globalThis.XMLHttpRequest = createXMLHttpRequestProxy({\n      emitter: this.emitter,\n      logger: this.logger,\n    })\n\n    logger.info(\n      'native \"XMLHttpRequest\" module patched!',\n      globalThis.XMLHttpRequest.name\n    )\n\n    Object.defineProperty(globalThis.XMLHttpRequest, IS_PATCHED_MODULE, {\n      enumerable: true,\n      configurable: true,\n      value: true,\n    })\n\n    this.subscriptions.push(() => {\n      Object.defineProperty(globalThis.XMLHttpRequest, IS_PATCHED_MODULE, {\n        value: undefined,\n      })\n\n      globalThis.XMLHttpRequest = PureXMLHttpRequest\n      logger.info(\n        'native \"XMLHttpRequest\" module restored!',\n        globalThis.XMLHttpRequest.name\n      )\n    })\n  }\n}\n", "import { until } from '@open-draft/until'\nimport type { Logger } from '@open-draft/logger'\nimport { XMLHttpRequestEmitter } from '.'\nimport { toInteractiveRequest } from '../../utils/toInteractiveRequest'\nimport { emitAsync } from '../../utils/emitAsync'\nimport { XMLHttpRequestController } from './XMLHttpRequestController'\n\nexport interface XMLHttpRequestProxyOptions {\n  emitter: XMLHttpRequestEmitter\n  logger: Logger\n}\n\n/**\n * Create a proxied `XMLHttpRequest` class.\n * The proxied class establishes spies on certain methods,\n * allowing us to intercept requests and respond to them.\n */\nexport function createXMLHttpRequestProxy({\n  emitter,\n  logger,\n}: XMLHttpRequestProxyOptions) {\n  const XMLHttpRequestProxy = new Proxy(globalThis.XMLHttpRequest, {\n    construct(target, args, newTarget) {\n      logger.info('constructed new XMLHttpRequest')\n\n      const originalRequest = Reflect.construct(\n        target,\n        args,\n        newTarget\n      ) as XMLHttpRequest\n\n      /**\n       * @note Forward prototype descriptors onto the proxied object.\n       * XMLHttpRequest is implemented in JSDOM in a way that assigns\n       * a bunch of descriptors, like \"set responseType()\" on the prototype.\n       * With this propagation, we make sure that those descriptors trigger\n       * when the user operates with the proxied request instance.\n       */\n      const prototypeDescriptors = Object.getOwnPropertyDescriptors(\n        target.prototype\n      )\n      for (const propertyName in prototypeDescriptors) {\n        Reflect.defineProperty(\n          originalRequest,\n          propertyName,\n          prototypeDescriptors[propertyName]\n        )\n      }\n\n      const xhrRequestController = new XMLHttpRequestController(\n        originalRequest,\n        logger\n      )\n\n      xhrRequestController.onRequest = async function ({ request, requestId }) {\n        const { interactiveRequest, requestController } =\n          toInteractiveRequest(request)\n\n        this.logger.info('awaiting mocked response...')\n\n        emitter.once('request', ({ requestId: pendingRequestId }) => {\n          if (pendingRequestId !== requestId) {\n            return\n          }\n\n          if (requestController.responsePromise.state === 'pending') {\n            requestController.respondWith(undefined)\n          }\n        })\n\n        const resolverResult = await until(async () => {\n          this.logger.info(\n            'emitting the \"request\" event for %s listener(s)...',\n            emitter.listenerCount('request')\n          )\n\n          await emitAsync(emitter, 'request', {\n            request: interactiveRequest,\n            requestId,\n          })\n\n          this.logger.info('all \"request\" listeners settled!')\n\n          const mockedResponse = await requestController.responsePromise\n\n          this.logger.info('event.respondWith called with:', mockedResponse)\n\n          return mockedResponse\n        })\n\n        if (resolverResult.error) {\n          this.logger.info(\n            'request listener threw an exception, aborting request...',\n            resolverResult.error\n          )\n\n          /**\n           * @todo Consider forwarding this error to the stderr as well\n           * since not all consumers are expecting to handle errors.\n           * If they don't, this error will be swallowed.\n           */\n          xhrRequestController.errorWith(resolverResult.error)\n          return\n        }\n\n        const mockedResponse = resolverResult.data\n\n        if (typeof mockedResponse !== 'undefined') {\n          this.logger.info(\n            'received mocked response: %d %s',\n            mockedResponse.status,\n            mockedResponse.statusText\n          )\n\n          if (mockedResponse.type === 'error') {\n            this.logger.info(\n              'received a network error response, rejecting the request promise...'\n            )\n\n            xhrRequestController.errorWith(new TypeError('Network error'))\n            return\n          }\n\n          return xhrRequestController.respondWith(mockedResponse)\n        }\n\n        this.logger.info(\n          'no mocked response received, performing request as-is...'\n        )\n      }\n\n      xhrRequestController.onResponse = async function ({\n        response,\n        isMockedResponse,\n        request,\n        requestId,\n      }) {\n        this.logger.info(\n          'emitting the \"response\" event for %s listener(s)...',\n          emitter.listenerCount('response')\n        )\n\n        emitter.emit('response', {\n          response,\n          isMockedResponse,\n          request,\n          requestId,\n        })\n      }\n\n      // Return the proxied request from the controller\n      // so that the controller can react to the consumer's interactions\n      // with this request (opening/sending/etc).\n      return xhrRequestController.request\n    },\n  })\n\n  return XMLHttpRequestProxy\n}\n", "import { invariant } from 'outvariant'\nimport { isNodeProcess } from 'is-node-process'\nimport type { Logger } from '@open-draft/logger'\nimport { concatArrayBuffer } from './utils/concatArrayBuffer'\nimport { createEvent } from './utils/createEvent'\nimport {\n  decodeBuffer,\n  encodeBuffer,\n  toArrayBuffer,\n} from '../../utils/bufferUtils'\nimport { createProxy } from '../../utils/createProxy'\nimport { isDomParserSupportedType } from './utils/isDomParserSupportedType'\nimport { parseJson } from '../../utils/parseJson'\nimport { createResponse } from './utils/createResponse'\nimport { INTERNAL_REQUEST_ID_HEADER_NAME } from '../../Interceptor'\nimport { createRequestId } from '../../createRequestId'\n\nconst IS_MOCKED_RESPONSE = Symbol('isMockedResponse')\nconst IS_NODE = isNodeProcess()\n\n/**\n * An `XMLHttpRequest` instance controller that allows us\n * to handle any given request instance (e.g. responding to it).\n */\nexport class XMLHttpRequestController {\n  public request: XMLHttpRequest\n  public requestId: string\n  public onRequest?: (\n    this: XMLHttpRequestController,\n    args: {\n      request: Request\n      requestId: string\n    }\n  ) => Promise<void>\n  public onResponse?: (\n    this: XMLHttpRequestController,\n    args: {\n      response: Response\n      isMockedResponse: boolean\n      request: Request\n      requestId: string\n    }\n  ) => void\n\n  private method: string = 'GET'\n  private url: URL = null as any\n  private requestHeaders: Headers\n  private requestBody?: XMLHttpRequestBodyInit | Document | null\n  private responseBuffer: Uint8Array\n  private events: Map<keyof XMLHttpRequestEventTargetEventMap, Array<Function>>\n\n  constructor(\n    readonly initialRequest: XMLHttpRequest,\n    public logger: Logger\n  ) {\n    this.events = new Map()\n    this.requestId = createRequestId()\n    this.requestHeaders = new Headers()\n    this.responseBuffer = new Uint8Array()\n\n    this.request = createProxy(initialRequest, {\n      setProperty: ([propertyName, nextValue], invoke) => {\n        switch (propertyName) {\n          case 'ontimeout': {\n            const eventName = propertyName.slice(\n              2\n            ) as keyof XMLHttpRequestEventTargetEventMap\n\n            /**\n             * @note Proxy callbacks to event listeners because JSDOM has trouble\n             * translating these properties to callbacks. It seemed to be operating\n             * on events exclusively.\n             */\n            this.request.addEventListener(eventName, nextValue as any)\n\n            return invoke()\n          }\n\n          default: {\n            return invoke()\n          }\n        }\n      },\n      methodCall: ([methodName, args], invoke) => {\n        switch (methodName) {\n          case 'open': {\n            const [method, url] = args as [string, string | undefined]\n\n            if (typeof url === 'undefined') {\n              this.method = 'GET'\n              this.url = toAbsoluteUrl(method)\n            } else {\n              this.method = method\n              this.url = toAbsoluteUrl(url)\n            }\n\n            this.logger = this.logger.extend(`${this.method} ${this.url.href}`)\n            this.logger.info('open', this.method, this.url.href)\n\n            return invoke()\n          }\n\n          case 'addEventListener': {\n            const [eventName, listener] = args as [\n              keyof XMLHttpRequestEventTargetEventMap,\n              Function,\n            ]\n\n            this.registerEvent(eventName, listener)\n            this.logger.info('addEventListener', eventName, listener)\n\n            return invoke()\n          }\n\n          case 'setRequestHeader': {\n            const [name, value] = args as [string, string]\n            this.requestHeaders.set(name, value)\n\n            this.logger.info('setRequestHeader', name, value)\n\n            return invoke()\n          }\n\n          case 'send': {\n            const [body] = args as [\n              body?: XMLHttpRequestBodyInit | Document | null,\n            ]\n\n            if (body != null) {\n              this.requestBody =\n                typeof body === 'string' ? encodeBuffer(body) : body\n            }\n\n            this.request.addEventListener('load', () => {\n              if (typeof this.onResponse !== 'undefined') {\n                // Create a Fetch API Response representation of whichever\n                // response this XMLHttpRequest received. Note those may\n                // be either a mocked and the original response.\n                const fetchResponse = createResponse(\n                  this.request,\n                  /**\n                   * The `response` property is the right way to read\n                   * the ambiguous response body, as the request's \"responseType\" may differ.\n                   * @see https://xhr.spec.whatwg.org/#the-response-attribute\n                   */\n                  this.request.response\n                )\n\n                // Notify the consumer about the response.\n                this.onResponse.call(this, {\n                  response: fetchResponse,\n                  isMockedResponse: IS_MOCKED_RESPONSE in this.request,\n                  request: fetchRequest,\n                  requestId: this.requestId!,\n                })\n              }\n            })\n\n            // Delegate request handling to the consumer.\n            const fetchRequest = this.toFetchApiRequest()\n            const onceRequestSettled =\n              this.onRequest?.call(this, {\n                request: fetchRequest,\n                requestId: this.requestId!,\n              }) || Promise.resolve()\n\n            onceRequestSettled.finally(() => {\n              // If the consumer didn't handle the request perform it as-is.\n              // Note that the request may not yet be DONE and may, in fact,\n              // be LOADING while the \"respondWith\" method does its magic.\n              if (this.request.readyState < this.request.LOADING) {\n                this.logger.info(\n                  'request callback settled but request has not been handled (readystate %d), performing as-is...',\n                  this.request.readyState\n                )\n\n                /**\n                 * @note Set the intercepted request ID on the original request in Node.js\n                 * so that if it triggers any other interceptors, they don't attempt\n                 * to process it once again.\n                 *\n                 * For instance, XMLHttpRequest is often implemented via \"http.ClientRequest\"\n                 * and we don't want for both XHR and ClientRequest interceptors to\n                 * handle the same request at the same time (e.g. emit the \"response\" event twice).\n                 */\n                if (IS_NODE) {\n                  this.request.setRequestHeader(\n                    INTERNAL_REQUEST_ID_HEADER_NAME,\n                    this.requestId!\n                  )\n                }\n\n                return invoke()\n              }\n            })\n\n            break\n          }\n\n          default: {\n            return invoke()\n          }\n        }\n      },\n    })\n  }\n\n  private registerEvent(\n    eventName: keyof XMLHttpRequestEventTargetEventMap,\n    listener: Function\n  ): void {\n    const prevEvents = this.events.get(eventName) || []\n    const nextEvents = prevEvents.concat(listener)\n    this.events.set(eventName, nextEvents)\n\n    this.logger.info('registered event \"%s\"', eventName, listener)\n  }\n\n  /**\n   * Responds to the current request with the given\n   * Fetch API `Response` instance.\n   */\n  public respondWith(response: Response): void {\n    this.logger.info(\n      'responding with a mocked response: %d %s',\n      response.status,\n      response.statusText\n    )\n\n    /**\n     * @note Since `XMLHttpRequestController` delegates the handling of the responses\n     * to the \"load\" event listener that doesn't distinguish between the mocked and original\n     * responses, mark the request that had a mocked response with a corresponding symbol.\n     */\n    define(this.request, IS_MOCKED_RESPONSE, true)\n\n    define(this.request, 'status', response.status)\n    define(this.request, 'statusText', response.statusText)\n    define(this.request, 'responseURL', this.url.href)\n\n    this.request.getResponseHeader = new Proxy(this.request.getResponseHeader, {\n      apply: (_, __, args: [name: string]) => {\n        this.logger.info('getResponseHeader', args[0])\n\n        if (this.request.readyState < this.request.HEADERS_RECEIVED) {\n          this.logger.info('headers not received yet, returning null')\n\n          // Headers not received yet, nothing to return.\n          return null\n        }\n\n        const headerValue = response.headers.get(args[0])\n        this.logger.info(\n          'resolved response header \"%s\" to',\n          args[0],\n          headerValue\n        )\n\n        return headerValue\n      },\n    })\n\n    this.request.getAllResponseHeaders = new Proxy(\n      this.request.getAllResponseHeaders,\n      {\n        apply: () => {\n          this.logger.info('getAllResponseHeaders')\n\n          if (this.request.readyState < this.request.HEADERS_RECEIVED) {\n            this.logger.info('headers not received yet, returning empty string')\n\n            // Headers not received yet, nothing to return.\n            return ''\n          }\n\n          const headersList = Array.from(response.headers.entries())\n          const allHeaders = headersList\n            .map(([headerName, headerValue]) => {\n              return `${headerName}: ${headerValue}`\n            })\n            .join('\\r\\n')\n\n          this.logger.info('resolved all response headers to', allHeaders)\n\n          return allHeaders\n        },\n      }\n    )\n\n    // Update the response getters to resolve against the mocked response.\n    Object.defineProperties(this.request, {\n      response: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.response,\n      },\n      responseText: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.responseText,\n      },\n      responseXML: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.responseXML,\n      },\n    })\n\n    const totalResponseBodyLength = response.headers.has('Content-Length')\n      ? Number(response.headers.get('Content-Length'))\n      : /**\n         * @todo Infer the response body length from the response body.\n         */\n        undefined\n\n    this.logger.info('calculated response body length', totalResponseBodyLength)\n\n    this.trigger('loadstart', {\n      loaded: 0,\n      total: totalResponseBodyLength,\n    })\n\n    this.setReadyState(this.request.HEADERS_RECEIVED)\n    this.setReadyState(this.request.LOADING)\n\n    const finalizeResponse = () => {\n      this.logger.info('finalizing the mocked response...')\n\n      this.setReadyState(this.request.DONE)\n\n      this.trigger('load', {\n        loaded: this.responseBuffer.byteLength,\n        total: totalResponseBodyLength,\n      })\n\n      this.trigger('loadend', {\n        loaded: this.responseBuffer.byteLength,\n        total: totalResponseBodyLength,\n      })\n    }\n\n    if (response.body) {\n      this.logger.info('mocked response has body, streaming...')\n\n      const reader = response.body.getReader()\n\n      const readNextResponseBodyChunk = async () => {\n        const { value, done } = await reader.read()\n\n        if (done) {\n          this.logger.info('response body stream done!')\n          finalizeResponse()\n          return\n        }\n\n        if (value) {\n          this.logger.info('read response body chunk:', value)\n          this.responseBuffer = concatArrayBuffer(this.responseBuffer, value)\n\n          this.trigger('progress', {\n            loaded: this.responseBuffer.byteLength,\n            total: totalResponseBodyLength,\n          })\n        }\n\n        readNextResponseBodyChunk()\n      }\n\n      readNextResponseBodyChunk()\n    } else {\n      finalizeResponse()\n    }\n  }\n\n  private responseBufferToText(): string {\n    return decodeBuffer(this.responseBuffer)\n  }\n\n  get response(): unknown {\n    this.logger.info(\n      'getResponse (responseType: %s)',\n      this.request.responseType\n    )\n\n    if (this.request.readyState !== this.request.DONE) {\n      return null\n    }\n\n    switch (this.request.responseType) {\n      case 'json': {\n        const responseJson = parseJson(this.responseBufferToText())\n        this.logger.info('resolved response JSON', responseJson)\n\n        return responseJson\n      }\n\n      case 'arraybuffer': {\n        const arrayBuffer = toArrayBuffer(this.responseBuffer)\n        this.logger.info('resolved response ArrayBuffer', arrayBuffer)\n\n        return arrayBuffer\n      }\n\n      case 'blob': {\n        const mimeType =\n          this.request.getResponseHeader('Content-Type') || 'text/plain'\n        const responseBlob = new Blob([this.responseBufferToText()], {\n          type: mimeType,\n        })\n\n        this.logger.info(\n          'resolved response Blob (mime type: %s)',\n          responseBlob,\n          mimeType\n        )\n\n        return responseBlob\n      }\n\n      default: {\n        const responseText = this.responseBufferToText()\n        this.logger.info(\n          'resolving \"%s\" response type as text',\n          this.request.responseType,\n          responseText\n        )\n\n        return responseText\n      }\n    }\n  }\n\n  get responseText(): string {\n    /**\n     * Throw when trying to read the response body as text when the\n     * \"responseType\" doesn't expect text. This just respects the spec better.\n     * @see https://xhr.spec.whatwg.org/#the-responsetext-attribute\n     */\n    invariant(\n      this.request.responseType === '' || this.request.responseType === 'text',\n      'InvalidStateError: The object is in invalid state.'\n    )\n\n    if (\n      this.request.readyState !== this.request.LOADING &&\n      this.request.readyState !== this.request.DONE\n    ) {\n      return ''\n    }\n\n    const responseText = this.responseBufferToText()\n    this.logger.info('getResponseText: \"%s\"', responseText)\n\n    return responseText\n  }\n\n  get responseXML(): Document | null {\n    invariant(\n      this.request.responseType === '' ||\n        this.request.responseType === 'document',\n      'InvalidStateError: The object is in invalid state.'\n    )\n\n    if (this.request.readyState !== this.request.DONE) {\n      return null\n    }\n\n    const contentType = this.request.getResponseHeader('Content-Type') || ''\n\n    if (typeof DOMParser === 'undefined') {\n      console.warn(\n        'Cannot retrieve XMLHttpRequest response body as XML: DOMParser is not defined. You are likely using an environment that is not browser or does not polyfill browser globals correctly.'\n      )\n      return null\n    }\n\n    if (isDomParserSupportedType(contentType)) {\n      return new DOMParser().parseFromString(\n        this.responseBufferToText(),\n        contentType\n      )\n    }\n\n    return null\n  }\n\n  public errorWith(error: Error): void {\n    this.logger.info('responding with an error')\n\n    this.setReadyState(this.request.DONE)\n    this.trigger('error')\n    this.trigger('loadend')\n  }\n\n  /**\n   * Transitions this request's `readyState` to the given one.\n   */\n  private setReadyState(nextReadyState: number): void {\n    this.logger.info(\n      'setReadyState: %d -> %d',\n      this.request.readyState,\n      nextReadyState\n    )\n\n    if (this.request.readyState === nextReadyState) {\n      this.logger.info('ready state identical, skipping transition...')\n      return\n    }\n\n    define(this.request, 'readyState', nextReadyState)\n\n    this.logger.info('set readyState to: %d', nextReadyState)\n\n    if (nextReadyState !== this.request.UNSENT) {\n      this.logger.info('triggerring \"readystatechange\" event...')\n\n      this.trigger('readystatechange')\n    }\n  }\n\n  /**\n   * Triggers given event on the `XMLHttpRequest` instance.\n   */\n  private trigger<\n    EventName extends keyof (XMLHttpRequestEventTargetEventMap & {\n      readystatechange: ProgressEvent<XMLHttpRequestEventTarget>\n    }),\n  >(eventName: EventName, options?: ProgressEventInit): void {\n    const callback = this.request[`on${eventName}`]\n    const event = createEvent(this.request, eventName, options)\n\n    this.logger.info('trigger \"%s\"', eventName, options || '')\n\n    // Invoke direct callbacks.\n    if (typeof callback === 'function') {\n      this.logger.info('found a direct \"%s\" callback, calling...', eventName)\n      callback.call(this.request, event)\n    }\n\n    // Invoke event listeners.\n    for (const [registeredEventName, listeners] of this.events) {\n      if (registeredEventName === eventName) {\n        this.logger.info(\n          'found %d listener(s) for \"%s\" event, calling...',\n          listeners.length,\n          eventName\n        )\n\n        listeners.forEach((listener) => listener.call(this.request, event))\n      }\n    }\n  }\n\n  /**\n   * Converts this `XMLHttpRequest` instance into a Fetch API `Request` instance.\n   */\n  public toFetchApiRequest(): Request {\n    this.logger.info('converting request to a Fetch API Request...')\n\n    const fetchRequest = new Request(this.url.href, {\n      method: this.method,\n      headers: this.requestHeaders,\n      /**\n       * @see https://xhr.spec.whatwg.org/#cross-origin-credentials\n       */\n      credentials: this.request.withCredentials ? 'include' : 'same-origin',\n      body: ['GET', 'HEAD'].includes(this.method)\n        ? null\n        : (this.requestBody as BodyInit),\n    })\n\n    const proxyHeaders = createProxy(fetchRequest.headers, {\n      methodCall: ([methodName, args], invoke) => {\n        // Forward the latest state of the internal request headers\n        // because the interceptor might have modified them\n        // without responding to the request.\n        switch (methodName) {\n          case 'append':\n          case 'set': {\n            const [headerName, headerValue] = args as [string, string]\n            this.request.setRequestHeader(headerName, headerValue)\n            break\n          }\n\n          case 'delete': {\n            const [headerName] = args as [string]\n            console.warn(\n              `XMLHttpRequest: Cannot remove a \"${headerName}\" header from the Fetch API representation of the \"${fetchRequest.method} ${fetchRequest.url}\" request. XMLHttpRequest headers cannot be removed.`\n            )\n            break\n          }\n        }\n\n        return invoke()\n      },\n    })\n    define(fetchRequest, 'headers', proxyHeaders)\n\n    this.logger.info('converted request to a Fetch API Request!', fetchRequest)\n\n    return fetchRequest\n  }\n}\n\nfunction toAbsoluteUrl(url: string | URL): URL {\n  /**\n   * @note XMLHttpRequest interceptor may run in environments\n   * that implement XMLHttpRequest but don't implement \"location\"\n   * (for example, React Native). If that's the case, return the\n   * input URL as-is (nothing to be relative to).\n   * @see https://github.com/mswjs/msw/issues/1777\n   */\n  if (typeof location === 'undefined') {\n    return new URL(url)\n  }\n\n  return new URL(url.toString(), location.href)\n}\n\nfunction define(\n  target: object,\n  property: string | symbol,\n  value: unknown\n): void {\n  Reflect.defineProperty(target, property, {\n    // Ensure writable properties to allow redefining readonly properties.\n    writable: true,\n    enumerable: true,\n    value,\n  })\n}\n", "/**\n * Concatenate two `Uint8Array` buffers.\n */\nexport function concatArrayBuffer(\n  left: Uint8Array,\n  right: Uint8Array\n): Uint8Array {\n  const result = new Uint8Array(left.byteLength + right.byteLength)\n  result.set(left, 0)\n  result.set(right, left.byteLength)\n  return result\n}\n", "export class EventPolyfill implements Event {\n  readonly AT_TARGET: number = 0\n  readonly BUBBLING_PHASE: number = 0\n  readonly CAPTURING_PHASE: number = 0\n  readonly NONE: number = 0\n\n  public type: string = ''\n  public srcElement: EventTarget | null = null\n  public target: EventTarget | null\n  public currentTarget: EventTarget | null = null\n  public eventPhase: number = 0\n  public timeStamp: number\n  public isTrusted: boolean = true\n  public composed: boolean = false\n  public cancelable: boolean = true\n  public defaultPrevented: boolean = false\n  public bubbles: boolean = true\n  public lengthComputable: boolean = true\n  public loaded: number = 0\n  public total: number = 0\n\n  cancelBubble: boolean = false\n  returnValue: boolean = true\n\n  constructor(\n    type: string,\n    options?: { target: EventTarget; currentTarget: EventTarget }\n  ) {\n    this.type = type\n    this.target = options?.target || null\n    this.currentTarget = options?.currentTarget || null\n    this.timeStamp = Date.now()\n  }\n\n  public composedPath(): EventTarget[] {\n    return []\n  }\n\n  public initEvent(type: string, bubbles?: boolean, cancelable?: boolean) {\n    this.type = type\n    this.bubbles = !!bubbles\n    this.cancelable = !!cancelable\n  }\n\n  public preventDefault() {\n    this.defaultPrevented = true\n  }\n\n  public stopPropagation() {}\n  public stopImmediatePropagation() {}\n}\n", "import { EventPolyfill } from './EventPolyfill'\n\nexport class ProgressEventPolyfill extends EventPolyfill {\n  readonly lengthComputable: boolean\n  readonly composed: boolean\n  readonly loaded: number\n  readonly total: number\n\n  constructor(type: string, init?: ProgressEventInit) {\n    super(type)\n\n    this.lengthComputable = init?.lengthComputable || false\n    this.composed = init?.composed || false\n    this.loaded = init?.loaded || 0\n    this.total = init?.total || 0\n  }\n}\n", "import { EventPolyfill } from '../polyfills/EventPolyfill'\nimport { ProgressEventPolyfill } from '../polyfills/ProgressEventPolyfill'\n\nconst SUPPORTS_PROGRESS_EVENT = typeof ProgressEvent !== 'undefined'\n\nexport function createEvent(\n  target: XMLHttpRequest,\n  type: string,\n  init?: ProgressEventInit\n): EventPolyfill {\n  const progressEvents = [\n    'error',\n    'progress',\n    'loadstart',\n    'loadend',\n    'load',\n    'timeout',\n    'abort',\n  ]\n\n  /**\n   * `ProgressEvent` is not supported in React Native.\n   * @see https://github.com/mswjs/interceptors/issues/40\n   */\n  const ProgressEventClass = SUPPORTS_PROGRESS_EVENT\n    ? ProgressEvent\n    : ProgressEventPolyfill\n\n  const event = progressEvents.includes(type)\n    ? new ProgressEventClass(type, {\n        lengthComputable: true,\n        loaded: init?.loaded || 0,\n        total: init?.total || 0,\n      })\n    : new EventPolyfill(type, {\n        target,\n        currentTarget: target,\n      })\n\n  return event\n}\n", "/**\n * Returns the source object of the given property on the target object\n * (the target itself, any parent in its prototype, or null).\n */\nexport function findPropertySource(\n  target: object,\n  propertyName: string | symbol\n): object | null {\n  if (!(propertyName in target)) {\n    return null\n  }\n\n  const hasProperty = Object.prototype.hasOwnProperty.call(target, propertyName)\n  if (hasProperty) {\n    return target\n  }\n\n  const prototype = Reflect.getPrototypeOf(target)\n  return prototype ? findPropertySource(prototype, propertyName) : null\n}\n", "import { findPropertySource } from './findPropertySource'\n\nexport interface ProxyOptions<Target extends Record<string, any>> {\n  constructorCall?(args: Array<unknown>, next: NextFunction<Target>): Target\n\n  methodCall?<F extends keyof Target>(\n    this: Target,\n    data: [methodName: F, args: Array<unknown>],\n    next: NextFunction<void>\n  ): void\n\n  setProperty?(\n    data: [propertyName: string | symbol, nextValue: unknown],\n    next: NextFunction<boolean>\n  ): boolean\n\n  getProperty?(\n    data: [propertyName: string | symbol, receiver: Target],\n    next: NextFunction<void>\n  ): void\n}\n\nexport type NextFunction<ReturnType> = () => ReturnType\n\nexport function createProxy<Target extends object>(\n  target: Target,\n  options: ProxyOptions<Target>\n): Target {\n  const proxy = new Proxy(target, optionsToProxyHandler(options))\n\n  return proxy\n}\n\nfunction optionsToProxyHandler<T extends Record<string, any>>(\n  options: ProxyOptions<T>\n): ProxyHandler<T> {\n  const { constructorCall, methodCall, getProperty, setProperty } = options\n  const handler: ProxyHandler<T> = {}\n\n  if (typeof constructorCall !== 'undefined') {\n    handler.construct = function (target, args, newTarget) {\n      const next = Reflect.construct.bind(null, target as any, args, newTarget)\n      return constructorCall.call(newTarget, args, next)\n    }\n  }\n\n  handler.set = function (target, propertyName, nextValue) {\n    const next = () => {\n      const propertySource = findPropertySource(target, propertyName) || target\n      const ownDescriptors = Reflect.getOwnPropertyDescriptor(\n        propertySource,\n        propertyName\n      )\n\n      // Respect any custom setters present for this property.\n      if (typeof ownDescriptors?.set !== 'undefined') {\n        ownDescriptors.set.apply(target, [nextValue])\n        return true\n      }\n\n      // Otherwise, set the property on the source.\n      return Reflect.defineProperty(propertySource, propertyName, {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value: nextValue,\n      })\n    }\n\n    if (typeof setProperty !== 'undefined') {\n      return setProperty.call(target, [propertyName, nextValue], next)\n    }\n\n    return next()\n  }\n\n  handler.get = function (target, propertyName, receiver) {\n    /**\n     * @note Using `Reflect.get()` here causes \"TypeError: Illegal invocation\".\n     */\n    const next = () => target[propertyName as any]\n\n    const value =\n      typeof getProperty !== 'undefined'\n        ? getProperty.call(target, [propertyName, receiver], next)\n        : next()\n\n    if (typeof value === 'function') {\n      return (...args: Array<any>) => {\n        const next = value.bind(target, ...args)\n\n        if (typeof methodCall !== 'undefined') {\n          return methodCall.call(target, [propertyName as any, args], next)\n        }\n\n        return next()\n      }\n    }\n\n    return value\n  }\n\n  return handler\n}\n", "export function isDomParserSupportedType(\n  type: string\n): type is DOMParserSupportedType {\n  const supportedTypes: Array<DOMParserSupportedType> = [\n    'application/xhtml+xml',\n    'application/xml',\n    'image/svg+xml',\n    'text/html',\n    'text/xml',\n  ]\n  return supportedTypes.some((supportedType) => {\n    return type.startsWith(supportedType)\n  })\n}\n", "/**\n * Parses a given string into JSON.\n * Gracefully handles invalid JSON by returning `null`.\n */\nexport function parseJson(data: string): Record<string, unknown> | null {\n  try {\n    const json = JSON.parse(data)\n    return json\n  } catch (_) {\n    return null\n  }\n}\n", "import { isResponseWithoutBody } from '../../../utils/responseUtils'\n\n/**\n * Creates a Fetch API `Response` instance from the given\n * `XMLHttpRequest` instance and a response body.\n */\nexport function createResponse(\n  request: XMLHttpRequest,\n  body: BodyInit | null\n): Response {\n  /**\n   * Handle XMLHttpRequest responses that must have null as the\n   * response body when represented using Fetch API Response.\n   * XMLHttpRequest response will always have an empty string\n   * as the \"request.response\" in those cases, resulting in an error\n   * when constructing a Response instance.\n   * @see https://github.com/mswjs/interceptors/issues/379\n   */\n  const responseBodyOrNull = isResponseWithoutBody(request.status) ? null : body\n\n  return new Response(responseBodyOrNull, {\n    status: request.status,\n    statusText: request.statusText,\n    headers: createHeadersFromXMLHttpReqestHeaders(\n      request.getAllResponseHeaders()\n    ),\n  })\n}\n\nfunction createHeadersFromXMLHttpReqestHeaders(headersString: string): Headers {\n  const headers = new Headers()\n\n  const lines = headersString.split(/[\\r\\n]+/)\n  for (const line of lines) {\n    if (line.trim() === '') {\n      continue\n    }\n\n    const [name, ...parts] = line.split(': ')\n    const value = parts.join(': ')\n\n    headers.append(name, value)\n  }\n\n  return headers\n}\n", "import {\n  Interceptor,\n  BatchInterceptor,\n  HttpRequestEventMap,\n} from '@mswjs/interceptors'\nimport { FetchInterceptor } from '@mswjs/interceptors/fetch'\nimport { XMLHttpRequestInterceptor } from '@mswjs/interceptors/XMLHttpRequest'\nimport { SetupWorkerInternalContext, StartOptions } from '../glossary'\nimport type { RequiredDeep } from '~/core/typeUtils'\nimport { handleRequest } from '~/core/utils/handleRequest'\n\nexport function createFallbackRequestListener(\n  context: SetupWorkerInternalContext,\n  options: RequiredDeep<StartOptions>,\n): Interceptor<HttpRequestEventMap> {\n  const interceptor = new BatchInterceptor({\n    name: 'fallback',\n    interceptors: [new FetchInterceptor(), new XMLHttpRequestInterceptor()],\n  })\n\n  interceptor.on('request', async ({ request, requestId }) => {\n    const requestCloneForLogs = request.clone()\n\n    const response = await handleRequest(\n      request,\n      requestId,\n      context.getRequestHandlers(),\n      options,\n      context.emitter,\n      {\n        onMockedResponse(_, { handler, parsedResult }) {\n          if (!options.quiet) {\n            context.emitter.once('response:mocked', ({ response }) => {\n              handler.log({\n                request: requestCloneForLogs,\n                response,\n                parsedResult,\n              })\n            })\n          }\n        },\n      },\n    )\n\n    if (response) {\n      request.respondWith(response)\n    }\n  })\n\n  interceptor.on(\n    'response',\n    ({ response, isMockedResponse, request, requestId }) => {\n      context.emitter.emit(\n        isMockedResponse ? 'response:mocked' : 'response:bypass',\n        {\n          response,\n          request,\n          requestId,\n        },\n      )\n    },\n  )\n\n  interceptor.apply()\n\n  return interceptor\n}\n", "import { createFallbackRequestListener } from './createFallbackRequestListener'\nimport { SetupWorkerInternalContext, StartHandler } from '../glossary'\nimport { printStartMessage } from './utils/printStartMessage'\n\nexport function createFallbackStart(\n  context: SetupWorkerInternalContext,\n): StartHandler {\n  return async function start(options) {\n    context.fallbackInterceptor = createFallbackRequestListener(\n      context,\n      options,\n    )\n\n    printStartMessage({\n      message: 'Mocking enabled (fallback mode).',\n      quiet: options.quiet,\n    })\n\n    return undefined\n  }\n}\n", "import { SetupWorkerInternalContext, StopHandler } from '../glossary'\nimport { printStopMessage } from './utils/printStopMessage'\n\nexport function createFallbackStop(\n  context: SetupWorkerInternalContext,\n): StopHandler {\n  return function stop() {\n    context.fallbackInterceptor?.dispose()\n    printStopMessage({ quiet: context.startOptions?.quiet })\n  }\n}\n", "import { invariant } from 'outvariant'\nimport { isNodeProcess } from 'is-node-process'\nimport {\n  SetupWorkerInternalContext,\n  ServiceWorkerIncomingEventsMap,\n  StartReturnType,\n  StopHandler,\n  StartHandler,\n  StartOptions,\n} from './glossary'\nimport { createStartHandler } from './start/createStartHandler'\nimport { createStop } from './stop/createStop'\nimport { ServiceWorkerMessage } from './start/utils/createMessageChannel'\nimport { RequestHandler } from '~/core/handlers/RequestHandler'\nimport { DEFAULT_START_OPTIONS } from './start/utils/prepareStartHandler'\nimport { createFallbackStart } from './start/createFallbackStart'\nimport { createFallbackStop } from './stop/createFallbackStop'\nimport { devUtils } from '~/core/utils/internal/devUtils'\nimport { SetupApi } from '~/core/SetupApi'\nimport { mergeRight } from '~/core/utils/internal/mergeRight'\nimport { LifeCycleEventsMap } from '~/core/sharedOptions'\nimport { SetupWorker } from './glossary'\nimport { supportsReadableStreamTransfer } from '../utils/supportsReadableStreamTransfer'\n\ninterface Listener {\n  target: EventTarget\n  eventType: string\n  callback: EventListenerOrEventListenerObject\n}\n\nexport class SetupWorkerApi\n  extends SetupApi<LifeCycleEventsMap>\n  implements SetupWorker\n{\n  private context: SetupWorkerInternalContext\n  private startHandler: StartHandler = null as any\n  private stopHandler: StopHandler = null as any\n  private listeners: Array<Listener>\n\n  constructor(...handlers: Array<RequestHandler>) {\n    super(...handlers)\n\n    invariant(\n      !isNodeProcess(),\n      devUtils.formatMessage(\n        'Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead.',\n      ),\n    )\n\n    this.listeners = []\n    this.context = this.createWorkerContext()\n  }\n\n  private createWorkerContext(): SetupWorkerInternalContext {\n    const context: SetupWorkerInternalContext = {\n      // Mocking is not considered enabled until the worker\n      // signals back the successful activation event.\n      isMockingEnabled: false,\n      startOptions: null as any,\n      worker: null,\n      getRequestHandlers: () => {\n        return this.handlersController.currentHandlers()\n      },\n      registration: null,\n      requests: new Map(),\n      emitter: this.emitter,\n      workerChannel: {\n        on: (eventType, callback) => {\n          this.context.events.addListener<\n            MessageEvent<ServiceWorkerMessage<typeof eventType, any>>\n          >(navigator.serviceWorker, 'message', (event) => {\n            // Avoid messages broadcasted from unrelated workers.\n            if (event.source !== this.context.worker) {\n              return\n            }\n\n            const message = event.data\n\n            if (!message) {\n              return\n            }\n\n            if (message.type === eventType) {\n              callback(event, message)\n            }\n          })\n        },\n        send: (type) => {\n          this.context.worker?.postMessage(type)\n        },\n      },\n      events: {\n        addListener: (target, eventType, callback) => {\n          target.addEventListener(eventType, callback as EventListener)\n          this.listeners.push({\n            eventType,\n            target,\n            callback: callback as EventListener,\n          })\n\n          return () => {\n            target.removeEventListener(eventType, callback as EventListener)\n          }\n        },\n        removeAllListeners: () => {\n          for (const { target, eventType, callback } of this.listeners) {\n            target.removeEventListener(eventType, callback)\n          }\n          this.listeners = []\n        },\n        once: (eventType) => {\n          const bindings: Array<() => void> = []\n\n          return new Promise<\n            ServiceWorkerMessage<\n              typeof eventType,\n              ServiceWorkerIncomingEventsMap[typeof eventType]\n            >\n          >((resolve, reject) => {\n            const handleIncomingMessage = (event: MessageEvent) => {\n              try {\n                const message = event.data\n\n                if (message.type === eventType) {\n                  resolve(message)\n                }\n              } catch (error) {\n                reject(error)\n              }\n            }\n\n            bindings.push(\n              this.context.events.addListener(\n                navigator.serviceWorker,\n                'message',\n                handleIncomingMessage,\n              ),\n              this.context.events.addListener(\n                navigator.serviceWorker,\n                'messageerror',\n                reject,\n              ),\n            )\n          }).finally(() => {\n            bindings.forEach((unbind) => unbind())\n          })\n        },\n      },\n      supports: {\n        serviceWorkerApi:\n          !('serviceWorker' in navigator) || location.protocol === 'file:',\n        readableStreamTransfer: supportsReadableStreamTransfer(),\n      },\n    }\n\n    this.startHandler = context.supports.serviceWorkerApi\n      ? createFallbackStart(context)\n      : createStartHandler(context)\n\n    this.stopHandler = context.supports.serviceWorkerApi\n      ? createFallbackStop(context)\n      : createStop(context)\n\n    return context\n  }\n\n  public async start(options: StartOptions = {}): StartReturnType {\n    if (options.waitUntilReady === true) {\n      devUtils.warn(\n        'The \"waitUntilReady\" option has been deprecated. Please remove it from this \"worker.start()\" call. Follow the recommended Browser integration (https://mswjs.io/docs/integrations/browser) to eliminate any race conditions between the Service Worker registration and any requests made by your application on initial render.',\n      )\n    }\n\n    this.context.startOptions = mergeRight(\n      DEFAULT_START_OPTIONS,\n      options,\n    ) as SetupWorkerInternalContext['startOptions']\n\n    return await this.startHandler(this.context.startOptions, options)\n  }\n\n  public stop(): void {\n    super.dispose()\n    this.context.events.removeAllListeners()\n    this.context.emitter.removeAllListeners()\n    this.stopHandler()\n  }\n}\n\n/**\n * Sets up a requests interception in the browser with the given request handlers.\n * @param {RequestHandler[]} handlers List of request handlers.\n *\n * @see {@link https://mswjs.io/docs/api/setup-worker `setupWorker()` API reference}\n */\nexport function setupWorker(...handlers: Array<RequestHandler>): SetupWorker {\n  return new SetupWorkerApi(...handlers)\n}\n", "/**\n * Returns a boolean indicating whether the current browser\n * supports `ReadableStream` as a `Transferable` when posting\n * messages.\n */\nexport function supportsReadableStreamTransfer() {\n  try {\n    const stream = new ReadableStream({\n      start: (controller) => controller.close(),\n    })\n    const message = new MessageChannel()\n    message.port1.postMessage(stream, [stream])\n    return true\n  } catch (error) {\n    return false\n  }\n}\n", "\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  getWorker: () => getWorker,\n  initialize: () => initialize,\n  mswDecorator: () => mswDecorator,\n  mswLoader: () => mswLoader\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/initialize.browser.ts\nvar import_browser = require(\"msw/browser\");\n\n// src/augmentInitializeOptions.ts\nvar fileExtensionPattern = /\\.(js|jsx|ts|tsx|mjs|woff|woff2|ttf|otf|eot)$/;\nvar filteredURLSubstrings = [\n  \"sb-common-assets\",\n  \"node_modules\",\n  \"node-modules\",\n  \"hot-update.json\",\n  \"__webpack_hmr\",\n  \"sb-vite\"\n];\nvar shouldFilterUrl = (url) => {\n  if (fileExtensionPattern.test(url)) {\n    return true;\n  }\n  const isStorybookRequest = filteredURLSubstrings.some(\n    (substring) => url.includes(substring)\n  );\n  if (isStorybookRequest) {\n    return true;\n  }\n  return false;\n};\nvar augmentInitializeOptions = (options) => {\n  if (typeof options?.onUnhandledRequest === \"string\") {\n    return options;\n  }\n  return {\n    ...options,\n    // Filter requests that we know are not relevant to the user e.g. HMR, builder requests, statics assets, etc.\n    onUnhandledRequest: (...args) => {\n      const [{ url }, print] = args;\n      if (shouldFilterUrl(url)) {\n        return;\n      }\n      if (!options?.onUnhandledRequest) {\n        print.warning();\n        return;\n      }\n      if (typeof options?.onUnhandledRequest === \"function\") {\n        options.onUnhandledRequest(...args);\n      }\n    }\n  };\n};\n\n// src/initialize.browser.ts\nvar api;\nfunction initialize(options, initialHandlers = []) {\n  const worker = (0, import_browser.setupWorker)(...initialHandlers);\n  worker.start(augmentInitializeOptions(options));\n  api = worker;\n  return worker;\n}\nfunction getWorker() {\n  if (api === void 0) {\n    throw new Error(\n      `[MSW] Failed to retrieve the worker: no active worker found. Did you forget to call \"initialize\"?`\n    );\n  }\n  return api;\n}\n\n// src/applyRequestHandlers.ts\nfunction applyRequestHandlers(handlersListOrObject) {\n  api?.resetHandlers();\n  if (handlersListOrObject == null) {\n    return;\n  }\n  if (Array.isArray(handlersListOrObject) && handlersListOrObject.length > 0) {\n    api.use(...handlersListOrObject);\n    return;\n  }\n  if (\"handlers\" in handlersListOrObject && handlersListOrObject.handlers) {\n    const handlers = Object.values(handlersListOrObject.handlers).filter(Boolean).reduce(\n      (handlers2, handlersList) => handlers2.concat(handlersList),\n      []\n    );\n    if (handlers.length > 0) {\n      api.use(...handlers);\n    }\n    return;\n  }\n}\n\n// src/decorator.ts\nvar mswDecorator = (storyFn, context) => {\n  applyRequestHandlers(context.parameters.msw);\n  return storyFn();\n};\n\n// src/loader.ts\nvar mswLoader = async (context) => {\n  applyRequestHandlers(context.parameters.msw);\n  if (typeof window !== \"undefined\" && \"navigator\" in window && navigator.serviceWorker.controller) {\n    await navigator.serviceWorker.ready;\n  }\n  return {};\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  getWorker,\n  initialize,\n  mswDecorator,\n  mswLoader\n});\n"],
  "mappings": "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",
  "names": ["strategy", "__commonJS", "exports", "module", "value", "cookies", "parseCookie", "sourceEmit", "error", "import_devUtils", "worker", "_a", "__defProp", "__export", "mockedResponse", "next", "IS_NODE", "invariant", "import_handleRequest", "response", "import_mergeRight"]
}
