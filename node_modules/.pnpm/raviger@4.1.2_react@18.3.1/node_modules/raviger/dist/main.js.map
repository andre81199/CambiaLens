{"version":3,"file":"main.js","sources":["../src/context.tsx","../src/node.ts","../src/intercept.ts","../src/location.ts","../src/hooks.ts","../src/typeChecks.ts","../src/router.tsx","../src/navigate.ts","../src/querystring.ts","../src/redirect.ts","../src/Link.tsx"],"sourcesContent":["import React, { createContext, useContext, useMemo } from 'react'\n\nconst BasePathContext = createContext('')\nconst PathContext = createContext<string | null>(null)\n\nexport { BasePathContext }\nexport { PathContext }\n\nexport function useRouter(): { basePath: string; path: string | null } {\n  const [basePath, path] = [useContext(BasePathContext), useContext(PathContext)]\n  return useMemo(() => ({ basePath, path }), [basePath, path])\n}\n\nexport function RouterProvider({\n  basePath = '',\n  path,\n  children,\n}: {\n  basePath?: string\n  path?: string\n  children?: React.ReactNode\n}): JSX.Element {\n  return (\n    // The ordering here is important, the basePath will change less often\n    // So putting it on the outside reduces its need to re-render\n    <BasePathContext.Provider value={basePath}>\n      <PathContext.Provider value={path ?? null}>{children}</PathContext.Provider>\n    </BasePathContext.Provider>\n  )\n}\n","let ssrPath = '/'\nlet isNode = true\ntry {\n  isNode = window === undefined\n} catch (e) {} // eslint-disable-line no-empty\n\nexport { isNode }\nexport function getSsrPath(): string {\n  return ssrPath\n}\nexport function setSsrPath(path: string): void {\n  ssrPath = path\n}\n","const interceptors = new Set<() => string | void>()\n\nexport const defaultPrompt = 'Are you sure you want to leave this page?'\n\nlet hasIntercepted = false\nlet hasUserCancelled = false\nlet lastScroll = [0, 0] as [number, number]\n\nexport function shouldCancelNavigation(): boolean {\n  lastScroll = [window.scrollX, window.scrollY]\n  if (hasIntercepted) return hasUserCancelled\n\n  // confirm if any interceptors return true\n  return Array.from(interceptors).some((interceptor) => {\n    const prompt = interceptor()\n    if (!prompt) return false\n\n    // cancel navigation if user declines\n    hasUserCancelled = !window.confirm(prompt) // eslint-disable-line no-alert\n\n    // track user response so that multiple interceptors don't prompt\n    hasIntercepted = true\n\n    // reset so that future navigation attempts are prompted\n    setTimeout(() => {\n      hasIntercepted = false\n      hasUserCancelled = false\n    }, 0)\n\n    return hasUserCancelled\n  })\n}\n\nexport function addInterceptor(handler: () => string | void): void {\n  window.addEventListener('beforeunload', handler)\n  interceptors.add(handler)\n}\n\nexport function removeInterceptor(handler: () => string | void): void {\n  window.removeEventListener('beforeunload', handler)\n  interceptors.delete(handler)\n}\n\nexport function undoNavigation(lastPath: string): void {\n  window.history.pushState(null, null as unknown as string, lastPath)\n  setTimeout(() => {\n    window.scrollTo(...lastScroll)\n  }, 0)\n}\n","import { useState, useCallback, useRef, useContext, useLayoutEffect } from 'react'\n\nimport { BasePathContext, PathContext } from './context'\nimport { useMountedLayout } from './hooks'\nimport { getSsrPath, isNode } from './node'\nimport { shouldCancelNavigation } from './intercept'\nimport { isFunction } from './typeChecks'\n\nexport interface RavigerLocation {\n  /** The current path; alias of `pathname` */\n  path: string | null\n  /** The current path; alias of `path` */\n  pathname: string | null\n  /** The full path, ignores any `basePath` in the context */\n  fullPath: string\n  basePath?: string\n  search: string\n  hash: string\n  host: string\n  hostname: string\n  href: string\n  origin: string\n}\n\nexport interface RavigerHistory {\n  scrollRestoration: 'auto' | 'manual'\n  state: unknown\n}\n\nexport interface LocationChangeSetFn {\n  (location: RavigerLocation): void\n}\nexport interface LocationChangeOptionParams {\n  inheritBasePath?: boolean\n  basePath?: string\n  isActive?: boolean | (() => boolean)\n  onInitial?: boolean\n}\n\nexport function usePath(basePath?: string): string | null {\n  const contextPath = useContext(PathContext)\n  const contextBasePath = useBasePath() // hooks can't be called conditionally\n  basePath = basePath || contextBasePath\n\n  // Don't bother tracking the actual path, it can get out of sync\n  // due to React parent/child render ordering, especially with onmount navigation\n  // See issues:\n  // https://github.com/kyeotic/raviger/issues/116\n  // https://github.com/kyeotic/raviger/issues/64\n  //\n  // This is just used to force a re-render\n  const [, setPath] = useState(getFormattedPath(basePath))\n  const onChange = useCallback(({ path: newPath }) => setPath(newPath), [])\n  useLocationChange(onChange, {\n    basePath,\n    inheritBasePath: !basePath,\n    // Use on initial to handle to force state updates from on-mount navigation\n    onInitial: true,\n  })\n\n  return contextPath || getFormattedPath(basePath)\n}\n\nexport function useBasePath(): string {\n  return useContext(BasePathContext)\n}\n\nexport function useFullPath(): string {\n  const [path, setPath] = useState<string | null>(getCurrentPath())\n  const onChange = useCallback(({ path: newPath }) => setPath(newPath), [])\n  useLocationChange(onChange, { inheritBasePath: false })\n\n  return path || '/'\n}\n\nexport function useHash({ stripHash = true } = {}): string {\n  const [hash, setHash] = useState(window.location.hash)\n  const handleHash = useCallback(() => {\n    const newHash = window.location.hash\n    if (newHash === hash) return\n    setHash(newHash)\n  }, [setHash, hash])\n\n  useLayoutEffect(() => {\n    window.addEventListener('hashchange', handleHash, false)\n    return () => window.removeEventListener('hashchange', handleHash)\n  }, [handleHash])\n\n  useLocationChange(handleHash)\n  return stripHash ? hash.substring(1) : hash\n}\n\nexport function getCurrentPath(): string {\n  return isNode ? getSsrPath() : window.location.pathname || '/'\n}\n\nexport function getCurrentHash(): string {\n  if (isNode) {\n    const path = getSsrPath()\n    const hashIndex = path.indexOf('#')\n    return path.substring(hashIndex)\n  }\n  return window.location.hash\n}\n\nexport function useLocationChange(\n  setFn: LocationChangeSetFn,\n  {\n    inheritBasePath = true,\n    basePath = '',\n    isActive,\n    onInitial = false,\n  }: LocationChangeOptionParams = {}\n): void {\n  if (isNode) return\n\n  // All hooks after this are conditional, but the runtime can't actually change\n  /* eslint-disable react-hooks/rules-of-hooks */\n\n  const routerBasePath = useBasePath()\n  if (inheritBasePath && routerBasePath) basePath = routerBasePath\n\n  const setRef = useRef<LocationChangeSetFn>(setFn)\n  useLayoutEffect(() => {\n    // setFn could be an in-render declared callback, making it unstable\n    // This is a method of using an often-changing callback from React Hooks\n    // https://reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback\n    // While not recommended, it is the best current (16.9) available method\n    // For reducing the useEffect cleanup from setFn changing every render\n    setRef.current = setFn\n  })\n\n  const onPopState = useCallback(() => {\n    // No predicate defaults true\n    if (isActive !== undefined && !isPredicateActive(isActive)) return\n    if (shouldCancelNavigation()) return\n    setRef.current(getFormattedLocation(basePath))\n  }, [isActive, basePath])\n\n  useLayoutEffect(() => {\n    window.addEventListener('popstate', onPopState)\n    return () => window.removeEventListener('popstate', onPopState)\n  }, [onPopState])\n\n  // When the basePath changes re-check the path after the render completes\n  // This allows nested contexts to get an up-to-date formatted path\n  useMountedLayout(\n    () => {\n      if (isActive !== undefined && !isPredicateActive(isActive)) return\n      setRef.current(getFormattedLocation(basePath))\n    },\n    [basePath, isActive],\n    { onInitial }\n  )\n}\n\nexport function useHistory(): RavigerHistory {\n  const [history, setHistory] = useState(getRavigerHistory())\n  useLocationChange(useCallback(() => setHistory(getRavigerHistory()), [setHistory]))\n  return history\n}\n\nfunction getRavigerHistory(): RavigerHistory {\n  if (isNode) return { scrollRestoration: 'manual', state: null }\n  return {\n    scrollRestoration: window.history.scrollRestoration,\n    state: window.history.state,\n  }\n}\n\n/**\n * Returns the current path after decoding. If basePath is provided it will be removed from the front of the path.\n * If basePath is provided and the path does not begin with it will return null\n * @param {string} basePath basePath, if any\n * @return {string | null} returns path with basePath prefix removed, or null if basePath is provided and missing\n */\nexport function getFormattedPath(basePath: string): string | null {\n  const path = getCurrentPath()\n  const baseMissing = basePath && !isPathInBase(basePath, path)\n  if (path === null || baseMissing) return null\n  return decodeURIComponent(!basePath ? path : path.replace(basePathMatcher(basePath), '') || '/')\n}\n\nfunction getFormattedLocation(basePath: string): RavigerLocation {\n  const path = getFormattedPath(basePath)\n  return {\n    basePath,\n    path,\n    pathname: path,\n    fullPath: getCurrentPath(),\n    search: window.location.search,\n    hash: getCurrentHash(),\n    host: window.location.host,\n    hostname: window.location.hostname,\n    href: window.location.href,\n    origin: window.location.origin,\n  }\n}\n\nfunction isPredicateActive(predicate: boolean | (() => boolean)): boolean {\n  return isFunction(predicate) ? predicate() : predicate\n}\n\nfunction basePathMatcher(basePath: string): RegExp {\n  return new RegExp('^' + basePath, 'i')\n}\n\nfunction isPathInBase(basePath: string, path: string): boolean {\n  return !!(basePath && path && path.toLowerCase().startsWith(basePath.toLowerCase()))\n}\n","import { useLayoutEffect, useRef } from 'react'\n\nexport function useMountedLayout(\n  fn: () => unknown,\n  deps: React.DependencyList | undefined,\n  { onInitial = false } = {}\n): void {\n  const hasMounted = useRef(onInitial)\n  useLayoutEffect(() => {\n    if (!hasMounted.current) hasMounted.current = true\n    else fn()\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps)\n}\n","// eslint-disable-next-line @typescript-eslint/ban-types, @typescript-eslint/explicit-module-boundary-types\nexport function isFunction(obj: unknown): obj is Function {\n  return !!obj && typeof obj === 'function'\n}\n","import React, { useCallback, useLayoutEffect, useMemo, useState } from 'react'\n\nimport { RouterProvider } from './context'\nimport { isNode, setSsrPath, getSsrPath } from './node'\nimport { getFormattedPath, usePath } from './location'\nimport type { NonEmptyRecord, Split, ValueOf } from './types'\n\nconst emptyPathResult: [null, null] = [null, null]\n\nexport interface PathParamOptions {\n  basePath?: string\n  matchTrailingSlash?: boolean\n}\nexport interface RouteOptionParams extends PathParamOptions {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  routeProps?: { [k: string]: any }\n  overridePathParams?: boolean\n}\ninterface RouteMatcher {\n  path: string\n  regex: RegExp\n  props: string[]\n}\n\ntype ExtractPathParams<Path extends string, Parts = Split<Path, '/'>> = Parts extends [\n  infer Head,\n  ...infer Tail\n]\n  ? Head extends `:${infer Name}`\n    ? { [N in Name]: string } & ExtractPathParams<Path, Tail>\n    : ExtractPathParams<Path, Tail>\n  : unknown\n\nexport type Routes<Path extends string> = {\n  [P in Path]: (\n    params: NonEmptyRecord<ExtractPathParams<P extends `${infer P1}*` ? P1 : P>>\n  ) => JSX.Element\n}\n\nexport function useRoutes<Path extends string>(\n  routes: Routes<Path>,\n  {\n    basePath = '',\n    routeProps = {},\n    overridePathParams = true,\n    matchTrailingSlash = true,\n  }: RouteOptionParams = {}\n): JSX.Element | null {\n  /*\n    This is a hack to setup a listener for the path while always using this latest path\n    The issue with usePath is that, in order to not re-render nested components when\n    their parent router changes the path, it uses the context's path\n    But since that path has to get _set_ here in useRoutes something has to give\n    If usePath returns latest it causes render thrashing\n    If useRoutes hacks itself into the latest path nothing bad happens (...afaik)\n  */\n  const path = usePath(basePath) && getFormattedPath(basePath)\n\n  // Handle potential <Redirect /> use in routes\n  useRedirectDetection(basePath, usePath(basePath))\n\n  // Get the current route\n  const route = useMatchRoute(routes, path, {\n    routeProps,\n    overridePathParams,\n    matchTrailingSlash,\n  })\n\n  // No match should not return an empty Provider, just null\n  if (!route || path === null) return null\n  return (\n    <RouterProvider basePath={basePath} path={path}>\n      {route}\n    </RouterProvider>\n  )\n}\n\nfunction useMatchRoute(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  routes: { [key: string]: (...props: any) => JSX.Element },\n  path: string | null,\n  {\n    routeProps,\n    overridePathParams,\n    matchTrailingSlash,\n  }: Omit<RouteOptionParams, 'basePath' | 'matchTrailingSlash'> & { matchTrailingSlash: boolean }\n) {\n  path = trailingMatch(path, matchTrailingSlash)\n  const matchers = useMatchers(Object.keys(routes))\n\n  if (path === null) return null\n  const [routeMatch, props] = getMatchParams(path, matchers)\n\n  if (!routeMatch) return null\n\n  return routes[routeMatch.path](\n    overridePathParams ? { ...props, ...routeProps } : { ...routeProps, ...props }\n  )\n}\n\nexport function usePathParams<Path extends string>(\n  route: Path,\n  options?: PathParamOptions\n): NonEmptyRecord<ExtractPathParams<Path extends `${infer P1}*` ? P1 : Path>> | null\nexport function usePathParams<Path extends string>(\n  routes: ReadonlyArray<Path>,\n  options?: PathParamOptions\n):\n  | ValueOf<{\n      [P in typeof routes[number]]: [\n        P,\n        NonEmptyRecord<ExtractPathParams<P extends `${infer P1}*` ? P1 : P>>\n      ]\n    }>\n  | [null, null]\nexport function usePathParams<Params extends ReadonlyArray<string> | string>(\n  routes: Params,\n  options: PathParamOptions = {}\n): Params extends ReadonlyArray<string>\n  ?\n      | ValueOf<{\n          [P in typeof routes[number]]: [\n            P,\n            NonEmptyRecord<ExtractPathParams<P extends `${infer P1}*` ? P1 : P>>\n          ]\n        }>\n      | [null, null]\n  : Params extends string\n  ? NonEmptyRecord<ExtractPathParams<Params extends `${infer P1}*` ? P1 : Params>> | null\n  : never {\n  const isSingle = !Array.isArray(routes)\n  const [path, matchers] = usePathOptions(routes as string | string[], options)\n\n  // @ts-expect-error inference is not carried forward and I don't know how to resolve this type\n  if (path === null) return isSingle ? null : emptyPathResult\n\n  const [routeMatch, props] = getMatchParams(path, matchers)\n  // @ts-expect-error inference is not carried forward and I don't know how to resolve this type\n  if (!routeMatch) return isSingle ? null : emptyPathResult\n\n  // @ts-expect-error inference is not carried forward and I don't know how to resolve this type\n  return isSingle\n    ? props\n    : ([routeMatch.path, props] as ValueOf<{\n        [P in typeof routes[number]]: [\n          P,\n          NonEmptyRecord<ExtractPathParams<P extends `${infer P1}*` ? P1 : P>>\n        ]\n      }>)\n}\n\nexport function useMatch(routes: string | string[], options: PathParamOptions = {}): string | null {\n  const [path, matchers] = usePathOptions(routes, options)\n  const match = matchers.find(({ regex }) => path?.match(regex))\n\n  return match?.path ?? null\n}\n\nfunction usePathOptions(\n  routeOrRoutes: string | string[],\n  { basePath, matchTrailingSlash = true }: PathParamOptions\n): [string | null, RouteMatcher[]] {\n  const routes = (!Array.isArray(routeOrRoutes) ? [routeOrRoutes] : routeOrRoutes) as string[]\n  const matchers = useMatchers(routes)\n\n  return [trailingMatch(usePath(basePath), matchTrailingSlash), matchers]\n}\n\nfunction useMatchers(routes: string[]): RouteMatcher[] {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return useMemo(() => routes.map(createRouteMatcher), [hashParams(routes)])\n}\n\nfunction getMatchParams(\n  path: string,\n  routeMatchers: RouteMatcher[]\n): [RouteMatcher, Record<string, unknown>] | [null, null] {\n  let pathParams: RegExpMatchArray | null = null\n\n  // Hacky method for find + map\n  const routeMatch = routeMatchers.find(({ regex }) => {\n    pathParams = path.match(regex)\n    return !!pathParams\n  })\n\n  if (!routeMatch || pathParams === null) return emptyPathResult\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const props = routeMatch.props.reduce((props: any, prop, i) => {\n    // The following `match` can't be null because the above return asserts it\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    props[prop] = pathParams![i + 1]\n    return props\n  }, {})\n\n  return [routeMatch, props]\n}\n\nfunction createRouteMatcher(path: string): RouteMatcher {\n  return {\n    path,\n    regex: new RegExp(\n      `${path.substr(0, 1) === '*' ? '' : '^'}${escapeRegExp(path)\n        .replace(/:[a-zA-Z]+/g, '([^/]+)')\n        .replace(/\\*/g, '')}${path.substr(-1) === '*' ? '' : '$'}`,\n      'i'\n    ),\n    props: (path.match(/:[a-zA-Z]+/g) ?? []).map((paramName) => paramName.substr(1)),\n  }\n}\n\nexport function setPath(path: string): void {\n  if (!isNode) {\n    throw new Error('This method should only be used in NodeJS environments')\n  }\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\n  const url = require('url')\n  setSsrPath(url.resolve(getSsrPath(), path))\n}\n\n// React doesn't like when the hook dependency array changes size\n// >> Warning: The final argument passed to useMemo changed size between renders. The order and size of this array must remain constant.\n// It is recommended to use a hashing function to produce a single, stable value\n// https://github.com/facebook/react/issues/14324#issuecomment-441489421\nfunction hashParams(params: string[]): string {\n  return [...params].sort().join(':')\n}\n\n// React appears to suppress parent's re-rendering when a child's\n// useLayoutEffect updates internal state\n// the `navigate` call in useRedirect *does* cause usePath/useLocationChange\n// to fire, but without this hack useRoutes suppresses the update\n// TODO: find a better way to cause a synchronous update from useRoutes\nfunction useRedirectDetection(basePath: string, path: string | null) {\n  const [, updateState] = useState({})\n  const forceRender = useCallback(() => updateState({}), [])\n\n  useLayoutEffect(() => {\n    if (path !== getFormattedPath(basePath)) {\n      forceRender()\n    }\n  }, [forceRender, basePath, path])\n}\n\nfunction trailingMatch(path: string | null, matchTrailingSlash: boolean): string | null {\n  if (path === null) return path\n  // path.length > 1 ensure we still match on the root route \"/\" when matchTrailingSlash is set\n  if (matchTrailingSlash && path && path[path.length - 1] === '/' && path.length > 1) {\n    path = path.substring(0, path.length - 1)\n  }\n  return path\n}\n\n// Taken from: https://stackoverflow.com/a/3561711\n// modified to NOT ESCAPE \"/\" and \"*\" since we use those as path parts\nfunction escapeRegExp(string: string): string {\n  return string.replace(/[-\\\\^$+?.()|[\\]{}]/g, '\\\\$&')\n}\n","import { useCallback, useLayoutEffect } from 'react'\n\nimport { useBasePath } from './location'\nimport { isNode } from './node'\nimport type { QueryParam } from './querystring'\nimport {\n  shouldCancelNavigation,\n  addInterceptor,\n  removeInterceptor,\n  defaultPrompt,\n  undoNavigation,\n} from './intercept'\n\nexport interface NavigateOptions {\n  /**\n   * Use a `replace` instead of `push` for navigation\n   * @default false */\n  replace?: boolean\n  /** Values to serialize as a querystring, which will be appended to the `url` */\n  query?: QueryParam | URLSearchParams\n  /**  value to pass as the state/data to history push/replace*/\n  state?: unknown\n}\n\nlet lastPath = ''\n\nexport function navigate(url: string, options?: NavigateOptions): void {\n  if (typeof url !== 'string') {\n    throw new Error(`\"url\" must be a string, was provided a(n) ${typeof url}`)\n  }\n\n  if (Array.isArray(options?.query)) {\n    throw new Error('\"query\" a serializable object or URLSearchParams')\n  }\n\n  if (shouldCancelNavigation()) return\n  if (options?.query) {\n    url += '?' + new URLSearchParams(options.query).toString()\n  }\n\n  lastPath = url\n  // if the origin does not match history navigation will fail with\n  // \"cannot be created in a document with origin\"\n  // When navigating to another domain we must use location instead of history\n  if (isAbsolute(url) && !isCurrentOrigin(url)) {\n    window.location.assign(url)\n    return\n  }\n\n  if (options?.replace) window.history.replaceState(options?.state, '', url)\n  else window.history.pushState(options?.state, '', url)\n\n  const event = new PopStateEvent('popstate')\n  // Tag the event so navigation can be filtered out from browser events\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ;(event as any).__tag = 'raviger:navigation'\n  dispatchEvent(event)\n}\n\nexport function useNavigationPrompt(predicate = true, prompt: string = defaultPrompt): void {\n  if (isNode) return\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  useLayoutEffect(() => {\n    const onPopStateNavigation = () => {\n      if (shouldCancelNavigation()) {\n        undoNavigation(lastPath)\n      }\n    }\n    window.addEventListener('popstate', onPopStateNavigation)\n    return () => window.removeEventListener('popstate', onPopStateNavigation)\n  }, [])\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  useLayoutEffect(() => {\n    const handler = (e?: BeforeUnloadEvent): string | void => {\n      if (predicate) {\n        return e ? cancelNavigation(e, prompt) : prompt\n      }\n    }\n    addInterceptor(handler)\n    return () => removeInterceptor(handler)\n  }, [predicate, prompt])\n}\n\nfunction cancelNavigation(event: BeforeUnloadEvent, prompt: string) {\n  // Cancel the event as stated by the standard.\n  event.preventDefault()\n  // Chrome requires returnValue to be set.\n  event.returnValue = prompt\n  // Return value for prompt per spec\n  return prompt\n}\n\nexport function useNavigate(optBasePath = ''): typeof navigate {\n  const basePath = useBasePath()\n  const navigateWithBasePath = useCallback<typeof navigate>(\n    (url: string, options?: NavigateOptions) => {\n      const base = optBasePath || basePath\n      const href = url.startsWith('/') ? base + url : url\n      navigate(href, options)\n    },\n    [basePath, optBasePath]\n  )\n  return navigateWithBasePath\n}\n\nfunction isAbsolute(url: string) {\n  return /^(?:[a-z]+:)?\\/\\//i.test(url)\n}\n\nfunction isCurrentOrigin(url: string) {\n  return window.location.origin === new URL(url).origin\n}\n","import { useState, useCallback } from 'react'\n\nimport { navigate } from './navigate'\nimport { isNode, getSsrPath } from './node'\nimport { getCurrentPath, getCurrentHash, useLocationChange } from './location'\n\nexport interface QueryParam {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [key: string]: any\n}\n\nexport interface setQueryParamsOptions {\n  replace?: boolean\n}\n\nexport function useQueryParams<T extends QueryParam>(\n  parseFn: (query: string) => T = parseQuery,\n  serializeFn: (query: Partial<T>) => string = serializeQuery\n): [T, (query: T, options?: setQueryParamsOptions) => void] {\n  const [querystring, setQuerystring] = useState(getQueryString())\n  const setQueryParams = useCallback(\n    (params, { replace = true } = {}) => {\n      let path = getCurrentPath()\n      params = replace ? params : { ...parseFn(querystring), ...params }\n      const serialized = serializeFn(params).toString()\n\n      if (serialized) path += '?' + serialized\n      if (!replace) path += getCurrentHash()\n\n      navigate(path)\n    },\n    [querystring, parseFn, serializeFn]\n  )\n\n  // Update state when route changes\n  const updateQuery = useCallback(() => setQuerystring(getQueryString()), [])\n\n  useLocationChange(updateQuery)\n  return [parseFn(querystring), setQueryParams]\n}\n\nfunction parseQuery<T extends QueryParam>(querystring: string): T {\n  const q = new URLSearchParams(querystring)\n  return Object.fromEntries(q.entries()) as T\n}\n\nfunction serializeQuery<T extends QueryParam>(queryParams: T): string {\n  return new URLSearchParams(Object.entries(queryParams).filter(([, v]) => v !== null)).toString()\n}\n\nexport function getQueryString(): string {\n  if (isNode) {\n    const ssrPath = getSsrPath()\n    const queryIndex = ssrPath.indexOf('?')\n    return queryIndex === -1 ? '' : ssrPath.substring(queryIndex + 1)\n  }\n  return window.location.search\n}\n","import { useLayoutEffect } from 'react'\n\nimport { getCurrentHash, usePath } from './location'\nimport { navigate } from './navigate'\nimport { QueryParam, useQueryParams } from './querystring'\n\nexport interface RedirectProps {\n  to: string\n  query?: QueryParam | URLSearchParams\n  replace?: boolean\n  merge?: boolean\n}\n\nexport interface UseRedirectProps {\n  predicateUrl: string\n  targetUrl: string\n  queryParams?: QueryParam | URLSearchParams\n  replace?: boolean\n}\n\nexport function Redirect({\n  to,\n  query,\n  replace = true,\n  merge = true,\n}: RedirectProps): JSX.Element | null {\n  useRedirect(usePath(), to, { query, replace, merge })\n  return null\n}\n\nexport function useRedirect(\n  predicateUrl: string | null,\n  targetUrl: string,\n  {\n    query,\n    replace = true,\n    merge = true,\n  }: { query?: QueryParam; replace?: boolean; merge?: boolean } = {}\n): void {\n  const currentPath = usePath()\n  const [currentQuery] = useQueryParams()\n  const hash = getCurrentHash()\n\n  let url = targetUrl\n  const targetQuery = new URLSearchParams({\n    ...(merge ? currentQuery : {}),\n    ...query,\n  }).toString()\n  if (targetQuery) {\n    url += '?' + targetQuery\n  }\n  if (merge && hash && hash.length) {\n    url += hash\n  }\n\n  useLayoutEffect(() => {\n    if (currentPath === predicateUrl) {\n      navigate(url, { replace })\n    }\n  }, [predicateUrl, url, replace, currentPath])\n}\n","import React, { useCallback, forwardRef, Ref } from 'react'\n\nimport { navigate } from './navigate'\nimport { useBasePath, useFullPath } from './location'\n\nexport interface LinkProps extends React.AnchorHTMLAttributes<HTMLAnchorElement> {\n  href: string\n  basePath?: string\n  children?: React.ReactNode\n}\nexport type LinkRef = HTMLAnchorElement | null\n\nexport interface ActiveLinkProps extends LinkProps {\n  activeClass?: string\n  exactActiveClass?: string\n}\n\nfunction Link({ href, basePath, ...props }: LinkProps, ref?: Ref<HTMLAnchorElement>) {\n  basePath = useLinkBasePath(basePath)\n  href = getLinkHref(href, basePath)\n\n  const { onClick, target } = props\n\n  const handleClick = useCallback<React.MouseEventHandler<HTMLAnchorElement>>(\n    (e) => {\n      try {\n        if (onClick) onClick(e)\n      } catch (ex) {\n        e.preventDefault()\n        throw ex\n      }\n      if (shouldTrap(e, target)) {\n        e.preventDefault() // prevent the link from actually navigating\n        navigate(e.currentTarget.href)\n      }\n    },\n    [onClick, target]\n  )\n\n  return <a {...props} href={href} onClick={handleClick} ref={ref} />\n}\n\nconst RefLink = forwardRef<LinkRef, LinkProps>(Link) as (\n  props: LinkProps & { ref?: React.ForwardedRef<HTMLAnchorElement> }\n) => ReturnType<typeof Link>\n\nexport default RefLink\nexport { RefLink as Link }\n\nfunction ActiveLink(\n  { basePath, className, exactActiveClass, activeClass, ...props }: ActiveLinkProps,\n  ref?: Ref<HTMLAnchorElement>\n) {\n  basePath = useLinkBasePath(basePath)\n  const fullPath = useFullPath()\n\n  let { href } = props\n  href = absolutePathName(getLinkHref(href, basePath))\n\n  if (exactActiveClass && fullPath === href)\n    className = `${className ?? ``} ${exactActiveClass}`.trim()\n  if (activeClass && fullPath.startsWith(href))\n    className = `${className ?? ``} ${activeClass}`.trim()\n\n  return <RefLink {...props} basePath={basePath} className={className} ref={ref} />\n}\n\nconst ActiveLinkRef = forwardRef<LinkRef, ActiveLinkProps>(ActiveLink) as (\n  props: ActiveLinkProps & { ref?: React.ForwardedRef<HTMLAnchorElement> }\n) => ReturnType<typeof ActiveLink>\n\nexport { ActiveLinkRef as ActiveLink }\n\nfunction useLinkBasePath(basePath?: string): string {\n  const contextBasePath = useBasePath()\n  if (basePath === '/') return ''\n  return basePath || contextBasePath\n}\n\nfunction getLinkHref(href: string, basePath = '') {\n  return href.startsWith('/') ? basePath + href : href\n}\n\nfunction absolutePathName(href: string): string {\n  if (href.startsWith('/')) return href\n  return new URL(href, document.baseURI).pathname\n}\n\nfunction shouldTrap(e: React.MouseEvent<HTMLAnchorElement, MouseEvent>, target?: string) {\n  return (\n    !e.defaultPrevented && // onClick prevented default\n    e.button === 0 && // ignore everything but left clicks\n    !(target || target === '_self') && // don't trap target === blank\n    !(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\n  )\n}\n"],"names":["BasePathContext","createContext","PathContext","RouterProvider","basePath","path","children","React","createElement","Provider","value","isNode","undefined","window","e","interceptors","Set","hasIntercepted","hasUserCancelled","lastScroll","shouldCancelNavigation","scrollX","scrollY","Array","from","some","interceptor","prompt","confirm","setTimeout","usePath","contextPath","useContext","contextBasePath","useBasePath","setPath","useState","getFormattedPath","useLocationChange","useCallback","newPath","inheritBasePath","onInitial","useFullPath","getCurrentPath","location","pathname","getCurrentHash","hashIndex","indexOf","substring","hash","setFn","isActive","routerBasePath","setRef","useRef","useLayoutEffect","current","onPopState","isPredicateActive","getFormattedLocation","addEventListener","removeEventListener","useMountedLayout","fn","deps","hasMounted","getRavigerHistory","scrollRestoration","state","history","baseMissing","isPathInBase","toLowerCase","startsWith","decodeURIComponent","replace","basePathMatcher","RegExp","fullPath","search","host","hostname","href","origin","predicate","isFunction","obj","emptyPathResult","usePathOptions","routeOrRoutes","matchTrailingSlash","matchers","useMatchers","isArray","trailingMatch","routes","useMemo","map","createRouteMatcher","params","sort","join","getMatchParams","routeMatchers","pathParams","routeMatch","find","regex","match","props","reduce","prop","i","string","substr","_a","paramName","length","lastPath","navigate","url","options","Error","query","URLSearchParams","toString","isAbsolute","test","isCurrentOrigin","URL","assign","replaceState","pushState","event","PopStateEvent","__tag","dispatchEvent","useQueryParams","parseFn","parseQuery","serializeFn","serializeQuery","querystring","setQuerystring","getQueryString","setQueryParams","serialized","q","Object","fromEntries","entries","queryParams","filter","v","ssrPath","queryIndex","useRedirect","predicateUrl","targetUrl","merge","currentPath","currentQuery","targetQuery","RefLink","forwardRef","Link","ref","getLinkHref","useLinkBasePath","onClick","target","handleClick","ex","preventDefault","shouldTrap","defaultPrevented","button","metaKey","altKey","ctrlKey","shiftKey","currentTarget","ActiveLinkRef","ActiveLink","className","exactActiveClass","activeClass","absolutePathName","document","baseURI","trim","Redirect","to","useHash","stripHash","setHash","handleHash","newHash","useHistory","setHistory","useMatch","useNavigate","optBasePath","base","useNavigationPrompt","onPopStateNavigation","undoNavigation","scrollTo","handler","cancelNavigation","returnValue","addInterceptor","add","removeInterceptor","delete","usePathParams","isSingle","useRoutes","routeProps","overridePathParams","useRedirectDetection","updateState","forceRender","route","useMatchRoute","keys"],"mappings":"2FAEA,MAAMA,EAAkBC,EAAAA,cAAc,IAChCC,EAAcD,EAAAA,cAA6B,MAU3C,SAAUE,gBAAeC,SAC7BA,EAAW,GAAEC,KACbA,EAAIC,SACJA,IAMA,OAGEC,EAAAC,cAACR,EAAgBS,SAAS,CAAAC,MAAON,GAC/BG,EAAAC,cAACN,EAAYO,UAASC,MAAOL,MAAAA,EAAAA,EAAQ,MAAOC,IC1BlD,IACIK,GAAS,EACb,IACEA,OAAoBC,IAAXC,OACT,MAAOC,ICJT,MAAMC,EAAe,IAAIC,IAIzB,IAAIC,GAAiB,EACjBC,GAAmB,EACnBC,EAAa,CAAC,EAAG,YAELC,yBAEd,OADAD,EAAa,CAACN,OAAOQ,QAASR,OAAOS,SACjCL,EAAuBC,EAGpBK,MAAMC,KAAKT,GAAcU,MAAMC,IACpC,MAAMC,EAASD,IACf,QAAKC,IAGLT,GAAoBL,OAAOe,QAAQD,GAGnCV,GAAiB,EAGjBY,YAAW,KACTZ,GAAiB,EACjBC,GAAmB,IAClB,GAEIA,MCUL,SAAUY,QAAQ1B,GACtB,MAAM2B,EAAcC,aAAW9B,GACzB+B,EAAkBC,cACxB9B,EAAWA,GAAY6B,EASvB,MAAM,CAAGE,GAAWC,EAAAA,SAASC,iBAAiBjC,IAS9C,OAPAkC,kBADiBC,eAAY,EAAGlC,KAAMmC,KAAcL,EAAQK,IAAU,IAC1C,CAC1BpC,SAAAA,EACAqC,iBAAkBrC,EAElBsC,WAAW,IAGNX,GAAeM,iBAAiBjC,YAGzB8B,cACd,OAAOF,EAAAA,WAAWhC,YAGJ2C,cACd,MAAOtC,EAAM8B,GAAWC,EAAAA,SAAwBQ,kBAIhD,OAFAN,kBADiBC,eAAY,EAAGlC,KAAMmC,KAAcL,EAAQK,IAAU,IAC1C,CAAEC,iBAAiB,IAExCpC,GAAQ,aAoBDuC,iBACd,OAAOjC,EF7FK,IE6FmBE,OAAOgC,SAASC,UAAY,aAG7CC,iBACd,GAAIpC,EAAQ,CACV,MAAMN,EFlGI,IEmGJ2C,EAAY3C,EAAK4C,QAAQ,KAC/B,OAAO5C,EAAK6C,UAAUF,GAExB,OAAOnC,OAAOgC,SAASM,KAGnB,SAAUb,kBACdc,GACAX,gBACEA,GAAkB,EAAIrC,SACtBA,EAAW,GAAEiD,SACbA,EAAQX,UACRA,GAAY,GACkB,IAEhC,GAAI/B,EAAQ,OAKZ,MAAM2C,EAAiBpB,cACnBO,GAAmBa,IAAgBlD,EAAWkD,GAElD,MAAMC,EAASC,SAA4BJ,GAC3CK,EAAAA,iBAAgB,KAMdF,EAAOG,QAAUN,KAGnB,MAAMO,EAAapB,EAAAA,aAAY,WAEZ3B,IAAbyC,GAA2BO,kBAAkBP,MAC7CjC,0BACJmC,EAAOG,QAAQG,qBAAqBzD,OACnC,CAACiD,EAAUjD,IAEdqD,EAAAA,iBAAgB,KACd5C,OAAOiD,iBAAiB,WAAYH,GAC7B,IAAM9C,OAAOkD,oBAAoB,WAAYJ,KACnD,CAACA,IC5IU,SAAAK,iBACdC,EACAC,GACAxB,UAAEA,GAAY,GAAU,IAExB,MAAMyB,EAAaX,SAAOd,GAC1Be,EAAAA,iBAAgB,KACTU,EAAWT,QACXO,IADoBE,EAAWT,SAAU,IAG7CQ,GDsIHF,EACE,WACmBpD,IAAbyC,GAA2BO,kBAAkBP,KACjDE,EAAOG,QAAQG,qBAAqBzD,MAEtC,CAACA,EAAUiD,GACX,CAAEX,UAAAA,IAUN,SAAS0B,oBACP,OAAIzD,EAAe,CAAE0D,kBAAmB,SAAUC,MAAO,MAClD,CACLD,kBAAmBxD,OAAO0D,QAAQF,kBAClCC,MAAOzD,OAAO0D,QAAQD,OAUpB,SAAUjC,iBAAiBjC,GAC/B,MAAMC,EAAOuC,iBACP4B,EAAcpE,IA6BtB,SAASqE,aAAarE,EAAkBC,GACtC,SAAUD,GAAYC,GAAQA,EAAKqE,cAAcC,WAAWvE,EAASsE,gBA9BpCD,CAAarE,EAAUC,GACxD,OAAa,OAATA,GAAiBmE,EAAoB,KAClCI,mBAAoBxE,EAAkBC,EAAKwE,QAuBpD,SAASC,gBAAgB1E,GACvB,OAAO,IAAI2E,OAAO,IAAM3E,EAAU,KAxBwB0E,CAAgB1E,GAAW,KAAO,IAAtDC,GAGxC,SAASwD,qBAAqBzD,GAC5B,MAAMC,EAAOgC,iBAAiBjC,GAC9B,MAAO,CACLA,SAAAA,EACAC,KAAAA,EACAyC,SAAUzC,EACV2E,SAAUpC,iBACVqC,OAAQpE,OAAOgC,SAASoC,OACxB9B,KAAMJ,iBACNmC,KAAMrE,OAAOgC,SAASqC,KACtBC,SAAUtE,OAAOgC,SAASsC,SAC1BC,KAAMvE,OAAOgC,SAASuC,KACtBC,OAAQxE,OAAOgC,SAASwC,QAI5B,SAASzB,kBAAkB0B,GACzB,OEvMI,SAAUC,WAAWC,GACzB,QAASA,GAAsB,mBAARA,EFsMhBD,CAAWD,GAAaA,IAAcA,EGjM/C,MAAMG,EAAgC,CAAC,KAAM,MAuJ7C,SAASC,eACPC,GACAvF,SAAEA,EAAQwF,mBAAEA,GAAqB,IAEjC,MACMC,EAAWC,YADAvE,MAAMwE,QAAQJ,GAAmCA,EAAlB,CAACA,IAGjD,MAAO,CAACK,cAAclE,QAAQ1B,GAAWwF,GAAqBC,GAGhE,SAASC,YAAYG,GAEnB,OAAOC,EAAOA,SAAC,IAAMD,EAAOE,IAAIC,qBAAqB,EAqDnCC,EArD+CJ,EAsD1D,IAAII,GAAQC,OAAOC,KAAK,QADjC,IAAoBF,EAlDpB,SAASG,eACPnG,EACAoG,GAEA,IAAIC,EAAsC,KAG1C,MAAMC,EAAaF,EAAcG,MAAK,EAAGC,MAAAA,MACvCH,EAAarG,EAAKyG,MAAMD,KACfH,KAGX,IAAKC,GAA6B,OAAfD,EAAqB,OAAOjB,EAE/C,MAAMsB,EAAQJ,EAAWI,MAAMC,QAAO,CAACD,EAAYE,EAAMC,KAGvDH,EAAME,GAAQP,EAAYQ,EAAI,GACvBH,IACN,IAEH,MAAO,CAACJ,EAAYI,GAGtB,SAASX,mBAAmB/F,SAyDN8G,EAxDpB,MAAO,CACL9G,KAAAA,EACAwG,MAAO,IAAI9B,OACT,GAAyB,MAAtB1E,EAAK+G,OAAO,EAAG,GAAa,GAAK,OAqDpBD,EArDuC9G,EAsDpD8G,EAAOtC,QAAQ,sBAAuB,SArDtCA,QAAQ,cAAe,WACvBA,QAAQ,MAAO,MAA0B,MAApBxE,EAAK+G,QAAQ,GAAa,GAAK,MACvD,KAEFL,OAAqC,QAA7BM,EAAAhH,EAAKyG,MAAM,sBAAkB,IAAAO,EAAAA,EAAA,IAAIlB,KAAKmB,GAAcA,EAAUF,OAAO,MAqCjF,SAASpB,cAAc3F,EAAqBuF,GAC1C,OAAa,OAATvF,GAEAuF,GAAsBvF,GAAkC,MAA1BA,EAAKA,EAAKkH,OAAS,IAAclH,EAAKkH,OAAS,IAC/ElH,EAAOA,EAAK6C,UAAU,EAAG7C,EAAKkH,OAAS,IAHflH,EC5N5B,IAAImH,EAAW,GAEC,SAAAC,SAASC,EAAaC,GACpC,GAAmB,iBAARD,EACT,MAAM,IAAIE,MAAM,oDAAoDF,GAGtE,GAAInG,MAAMwE,QAAQ4B,MAAAA,OAAO,EAAPA,EAASE,OACzB,MAAM,IAAID,MAAM,oDAGlB,GAAIxG,yBAA0B,OAS9B,IARIuG,MAAAA,SAAAA,EAASE,SACXH,GAAO,IAAM,IAAII,gBAAgBH,EAAQE,OAAOE,YAGlDP,EAAWE,EAmEb,SAASM,WAAWN,GAClB,MAAO,qBAAqBO,KAAKP,GAhE7BM,CAAWN,KAmEjB,SAASQ,gBAAgBR,GACvB,OAAO7G,OAAOgC,SAASwC,SAAW,IAAI8C,IAAIT,GAAKrC,OApEvB6C,CAAgBR,GAEtC,YADA7G,OAAOgC,SAASuF,OAAOV,IAIrBC,MAAAA,OAAA,EAAAA,EAAS9C,SAAShE,OAAO0D,QAAQ8D,aAAaV,MAAAA,OAAA,EAAAA,EAASrD,MAAO,GAAIoD,GACjE7G,OAAO0D,QAAQ+D,UAAUX,MAAAA,OAAA,EAAAA,EAASrD,MAAO,GAAIoD,GAElD,MAAMa,EAAQ,IAAIC,cAAc,YAG9BD,EAAcE,MAAQ,qBACxBC,cAAcH,YCzCAI,eACdC,EAAgCC,WAChCC,EAA6CC,gBAE7C,MAAOC,EAAaC,GAAkB7G,EAAAA,SAAS8G,kBACzCC,EAAiB5G,EAAAA,aACrB,CAAC8D,GAAUxB,QAAAA,GAAU,GAAS,MAC5B,IAAIxE,EAAOuC,iBACXyD,EAASxB,EAAUwB,EAAS,IAAKuC,EAAQI,MAAiB3C,GAC1D,MAAM+C,EAAaN,EAAYzC,GAAQ0B,WAEnCqB,IAAY/I,GAAQ,IAAM+I,GACzBvE,IAASxE,GAAQ0C,kBAEtB0E,SAASpH,KAEX,CAAC2I,EAAaJ,EAASE,IAOzB,OADAxG,kBAFoBC,EAAAA,aAAY,IAAM0G,EAAeC,mBAAmB,KAGjE,CAACN,EAAQI,GAAcG,GAGhC,SAASN,WAAiCG,GACxC,MAAMK,EAAI,IAAIvB,gBAAgBkB,GAC9B,OAAOM,OAAOC,YAAYF,EAAEG,WAG9B,SAAST,eAAqCU,GAC5C,OAAO,IAAI3B,gBAAgBwB,OAAOE,QAAQC,GAAaC,QAAO,EAAI,CAAAC,KAAa,OAANA,KAAa5B,oBAGxEmB,iBACd,GAAIvI,EAAQ,CACV,MAAMiJ,EPpDI,IOqDJC,EAAaD,EAAQ3G,QAAQ,KACnC,OAAuB,IAAhB4G,EAAoB,GAAKD,EAAQ1G,UAAU2G,EAAa,GAEjE,OAAOhJ,OAAOgC,SAASoC,gBC1BT6E,YACdC,EACAC,GACAnC,MACEA,EAAKhD,QACLA,GAAU,EAAIoF,MACdA,GAAQ,GACsD,IAEhE,MAAMC,EAAcpI,WACbqI,GAAgBxB,iBACjBxF,EAAOJ,iBAEb,IAAI2E,EAAMsC,EACV,MAAMI,EAAc,IAAItC,gBAAgB,IAClCmC,EAAQE,EAAe,MACxBtC,IACFE,WACCqC,IACF1C,GAAO,IAAM0C,GAEXH,GAAS9G,GAAQA,EAAKoE,SACxBG,GAAOvE,GAGTM,EAAAA,iBAAgB,KACVyG,IAAgBH,GAClBtC,SAASC,EAAK,CAAE7C,QAAAA,MAEjB,CAACkF,EAAcrC,EAAK7C,EAASqF,ICjBlC,MAAMG,EAAUC,EAAUA,YAzB1B,SAASC,MAAKnF,KAAEA,EAAIhF,SAAEA,KAAa2G,GAAoByD,GAErDpF,EAAOqF,YAAYrF,EADnBhF,EAAWsK,gBAAgBtK,IAG3B,MAAMuK,QAAEA,EAAOC,OAAEA,GAAW7D,EAEtB8D,EAActI,eACjBzB,IACC,IACM6J,GAASA,EAAQ7J,GACrB,MAAOgK,GAEP,MADAhK,EAAEiK,iBACID,GA2Dd,SAASE,WAAWlK,EAAoD8J,GACtE,OACG9J,EAAEmK,kBACU,IAAbnK,EAAEoK,UACAN,GAAqB,UAAXA,MACV9J,EAAEqK,SAAWrK,EAAEsK,QAAUtK,EAAEuK,SAAWvK,EAAEwK,WA9DpCN,CAAWlK,EAAG8J,KAChB9J,EAAEiK,iBACFtD,SAAS3G,EAAEyK,cAAcnG,SAG7B,CAACuF,EAASC,IAGZ,OAAOrK,EAAOC,cAAA,IAAA,IAAAuG,EAAO3B,KAAMA,EAAMuF,QAASE,EAAaL,IAAKA,OA4B9D,MAAMgB,EAAgBlB,EAAUA,YAlBhC,SAASmB,YACPrL,SAAEA,EAAQsL,UAAEA,EAASC,iBAAEA,EAAgBC,YAAEA,KAAgB7E,GACzDyD,GAEApK,EAAWsK,gBAAgBtK,GAC3B,MAAM4E,EAAWrC,cAEjB,IAAIyC,KAAEA,GAAS2B,EAQf,OAPA3B,EA0BF,SAASyG,iBAAiBzG,GACxB,OAAIA,EAAKT,WAAW,KAAaS,EAC1B,IAAI+C,IAAI/C,EAAM0G,SAASC,SAASjJ,SA5BhC+I,CAAiBpB,YAAYrF,EAAMhF,IAEtCuL,GAAoB3G,IAAaI,IACnCsG,EAAY,GAAGA,MAAAA,EAAAA,EAAa,MAAMC,IAAmBK,QACnDJ,GAAe5G,EAASL,WAAWS,KACrCsG,EAAY,GAAGA,MAAAA,EAAAA,EAAa,MAAME,IAAcI,QAE3CzL,gBAAC8J,EAAO,IAAKtD,EAAO3G,SAAUA,EAAUsL,UAAWA,EAAWlB,IAAKA,OAS5E,SAASE,gBAAgBtK,GACvB,MAAM6B,EAAkBC,cACxB,MAAiB,MAAb9B,EAAyB,GACtBA,GAAY6B,EAGrB,SAASwI,YAAYrF,EAAchF,EAAW,IAC5C,OAAOgF,EAAKT,WAAW,KAAOvE,EAAWgF,EAAOA,uDD5DlC,SAAA6G,UAASC,GACvBA,EAAErE,MACFA,EAAKhD,QACLA,GAAU,EAAIoF,MACdA,GAAQ,IAGR,OADAH,YAAYhI,UAAWoK,EAAI,CAAErE,MAAAA,EAAOhD,QAAAA,EAASoF,MAAAA,IACtC,sJNgDH,SAAUkC,SAAQC,UAAEA,GAAY,GAAS,IAC7C,MAAOjJ,EAAMkJ,GAAWjK,EAAQA,SAACvB,OAAOgC,SAASM,MAC3CmJ,EAAa/J,EAAAA,aAAY,KAC7B,MAAMgK,EAAU1L,OAAOgC,SAASM,KAC5BoJ,IAAYpJ,GAChBkJ,EAAQE,KACP,CAACF,EAASlJ,IAQb,OANAM,EAAAA,iBAAgB,KACd5C,OAAOiD,iBAAiB,aAAcwI,GAAY,GAC3C,IAAMzL,OAAOkD,oBAAoB,aAAcuI,KACrD,CAACA,IAEJhK,kBAAkBgK,GACXF,EAAYjJ,EAAKD,UAAU,GAAKC,+BAmEzBqJ,aACd,MAAOjI,EAASkI,GAAcrK,EAAAA,SAASgC,qBAEvC,OADA9B,kBAAkBC,EAAAA,aAAY,IAAMkK,EAAWrI,sBAAsB,CAACqI,KAC/DlI,yEGROmI,SAASzG,EAA2B0B,EAA4B,UAC9E,MAAOtH,EAAMwF,GAAYH,eAAeO,EAAQ0B,GAC1Cb,EAAQjB,EAASe,MAAK,EAAGC,MAAAA,KAAYxG,MAAAA,OAAI,EAAJA,EAAMyG,MAAMD,KAEvD,OAAsB,QAAfQ,EAAAP,MAAAA,OAAK,EAALA,EAAOzG,YAAQ,IAAAgH,EAAAA,EAAA,0BC7DR,SAAAsF,YAAYC,EAAc,IACxC,MAAMxM,EAAW8B,cASjB,OAR6BK,EAAAA,aAC3B,CAACmF,EAAaC,KACZ,MAAMkF,EAAOD,GAAexM,EAE5BqH,SADaC,EAAI/C,WAAW,KAAOkI,EAAOnF,EAAMA,EACjCC,KAEjB,CAACvH,EAAUwM,iCA3CT,SAAUE,oBAAoBxH,GAAY,EAAM3D,ELzDzB,6CK0DvBhB,IAGJ8C,EAAAA,iBAAgB,KACd,MAAMsJ,qBAAuB,KACvB3L,0BLtBJ,SAAU4L,eAAexF,GAC7B3G,OAAO0D,QAAQ+D,UAAU,KAAM,KAA2Bd,GAC1D3F,YAAW,KACThB,OAAOoM,YAAY9L,KAClB,GKmBG6L,CAAexF,IAInB,OADA3G,OAAOiD,iBAAiB,WAAYiJ,sBAC7B,IAAMlM,OAAOkD,oBAAoB,WAAYgJ,wBACnD,IAGHtJ,EAAAA,iBAAgB,KACd,MAAMyJ,QAAWpM,IACf,GAAIwE,EACF,OAAOxE,EAQf,SAASqM,iBAAiB5E,EAA0B5G,GAMlD,OAJA4G,EAAMwC,iBAENxC,EAAM6E,YAAczL,EAEbA,EAdUwL,CAAiBrM,EAAGa,GAAUA,GAI7C,OLhDE,SAAU0L,eAAeH,GAC7BrM,OAAOiD,iBAAiB,eAAgBoJ,GACxCnM,EAAauM,IAAIJ,GK6CfG,CAAeH,SACR,IL3CL,SAAUK,kBAAkBL,GAChCrM,OAAOkD,oBAAoB,eAAgBmJ,GAC3CnM,EAAayM,OAAON,GKyCLK,CAAkBL,WAC9B,CAAC5H,EAAW3D,6DDiCD8L,cACdxH,EACA0B,EAA4B,IAa5B,MAAM+F,GAAYnM,MAAMwE,QAAQE,IACzB5F,EAAMwF,GAAYH,eAAeO,EAA6B0B,GAGrE,GAAa,OAATtH,EAAe,OAAOqN,EAAW,KAAOjI,EAE5C,MAAOkB,EAAYI,GAASP,eAAenG,EAAMwF,GAEjD,OAAKc,EAGE+G,EACH3G,EACC,CAACJ,EAAWtG,KAAM0G,GALC2G,EAAW,KAAOjI,2FAnGtC,SAAUkI,UACd1H,GACA7F,SACEA,EAAW,GAAEwN,WACbA,EAAa,GAAEC,mBACfA,GAAqB,EAAIjI,mBACzBA,GAAqB,GACA,IAUvB,MAAMvF,EAAOyB,QAAQ1B,IAAaiC,iBAAiBjC,IAgLrD,SAAS0N,qBAAqB1N,EAAkBC,GAC9C,OAAS0N,GAAe3L,EAAQA,SAAC,IAC3B4L,EAAczL,EAAAA,aAAY,IAAMwL,EAAY,KAAK,IAEvDtK,EAAAA,iBAAgB,KACVpD,IAASgC,iBAAiBjC,IAC5B4N,MAED,CAACA,EAAa5N,EAAUC,IArL3ByN,CAAqB1N,EAAU0B,QAAQ1B,IAGvC,MAAM6N,EAeR,SAASC,cAEPjI,EACA5F,GACAuN,WACEA,EAAUC,mBACVA,EAAkBjI,mBAClBA,IAGFvF,EAAO2F,cAAc3F,EAAMuF,GAC3B,MAAMC,EAAWC,YAAYwD,OAAO6E,KAAKlI,IAEzC,GAAa,OAAT5F,EAAe,OAAO,KAC1B,MAAOsG,EAAYI,GAASP,eAAenG,EAAMwF,GAEjD,OAAKc,EAEEV,EAAOU,EAAWtG,MACvBwN,EAAqB,IAAK9G,KAAU6G,GAAe,IAAKA,KAAe7G,IAHjD,KA/BVmH,CAAcjI,EAAQ5F,EAAM,CACxCuN,WAAAA,EACAC,mBAAAA,EACAjI,mBAAAA,IAIF,OAAKqI,GAAkB,OAAT5N,EAEZE,EAAAC,cAACL,eAAc,CAACC,SAAUA,EAAUC,KAAMA,GACvC4N,GAH+B"}