/// <reference types="react" />
import type { NonEmptyRecord, Split, ValueOf } from './types';
export interface PathParamOptions {
    basePath?: string;
    matchTrailingSlash?: boolean;
}
export interface RouteOptionParams extends PathParamOptions {
    routeProps?: {
        [k: string]: any;
    };
    overridePathParams?: boolean;
}
declare type ExtractPathParams<Path extends string, Parts = Split<Path, '/'>> = Parts extends [
    infer Head,
    ...infer Tail
] ? Head extends `:${infer Name}` ? {
    [N in Name]: string;
} & ExtractPathParams<Path, Tail> : ExtractPathParams<Path, Tail> : unknown;
export declare type Routes<Path extends string> = {
    [P in Path]: (params: NonEmptyRecord<ExtractPathParams<P extends `${infer P1}*` ? P1 : P>>) => JSX.Element;
};
export declare function useRoutes<Path extends string>(routes: Routes<Path>, { basePath, routeProps, overridePathParams, matchTrailingSlash, }?: RouteOptionParams): JSX.Element | null;
export declare function usePathParams<Path extends string>(route: Path, options?: PathParamOptions): NonEmptyRecord<ExtractPathParams<Path extends `${infer P1}*` ? P1 : Path>> | null;
export declare function usePathParams<Path extends string>(routes: ReadonlyArray<Path>, options?: PathParamOptions): ValueOf<{
    [P in typeof routes[number]]: [
        P,
        NonEmptyRecord<ExtractPathParams<P extends `${infer P1}*` ? P1 : P>>
    ];
}> | [null, null];
export declare function useMatch(routes: string | string[], options?: PathParamOptions): string | null;
export declare function setPath(path: string): void;
export {};
